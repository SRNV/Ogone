import type { GLClearColorType, WebGLFusionType } from './public/types.ts';
// WebGL coordinates:
//   x: horizontal right direction is positive
//   y: vertical top direction is positive
//   z: depth line of sight is negative
// the attributes: width and height are required
<template>
  <canvas
    width="500px"
    height="500px"
    ref="canvases" />
    <div>
      number of points: ${this.count}
    </div>
</template>
<proto
  type="app"
  base="./public">
  declare:
    count: number = 0;
    getWebGLContext(canvas: HTMLCanvasElement): WebGLFusionType | never {
        // need to get the correct webgl context
      const gl = canvas.getContext('webgl2')
        || canvas.getContext('webgl')
        || canvas.getContext('experimental-webgl');
      if (gl && (gl instanceof WebGLRenderingContext || gl instanceof WebGL2RenderingContext)) {
        console.log('Ogone - WebGL context retrieved');
      } else {
        throw new Error('Ogone is not able to get WebGL context, your browser or device may not support WebGL.')
      }
      return gl;
    }
    setCanvasBackground(gl: WebGLFusionType, color: GLClearColorType): void {
      // set the color of the background
      // a VXComponent can provide it with the attribute background
      gl.clearColor(...color); // RGBA
      // apply the clear color to get the result
      gl.clear(gl.COLOR_BUFFER_BIT);
    }
    createVertexShader(gl: WebGLFusionType, source: string,): any {
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      if (!vertexShader) throw new Error('Ogone - failed to vertex shader.');
      gl.shaderSource(vertexShader, source.trim());
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(vertexShader);
        throw new Error('failed to compile vertex shader.\n\n' + info);
      }
      return vertexShader;
    }
    createFragmentShader(gl: WebGLFusionType, source: string,): any {
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      if (!fragmentShader) throw new Error('Ogone - failed to create fragment shader.');
      gl.shaderSource(fragmentShader, source.trim());
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(fragmentShader);
        throw new Error('failed to compile fragment shader.\n\n' + info);
      }
      return fragmentShader;
    }
    createProgram(gl: WebGLFusionType, opts: [string, string] = ['', '']): WebGLProgram {
      // the variable gl_Position is required
      const vertexShader = this.createVertexShader(gl, opts[0]);
      const fragmentShader = this.createFragmentShader(gl, opts[1]);
      const program = gl.createProgram();
      if (!program) throw new Error('Ogone - failed to create program.');
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(fragmentShader);
        throw new Error('Ogone - failed to compile WebGL Program.\n\n' + info);
      }
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      if (!gl.getProgramParameter( program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program);
        throw new Error('Could not compile WebGL program. \n\n' + info);
      }
      // use the program defined before
      gl.validateProgram(program);
      gl.useProgram(program);
      return program;
    }

    createBufferWithVertices(gl: WebGLFusionType, vertices: Float32Array) {
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      return buffer;
    }
    setVertexAttribute(gl: WebGLFusionType, opts: { values: any[]; name: string; program: WebGLProgram }) {
      const { name, values, program } = opts;
      // retrieve the attribute location of the attribute, in the program
      const vertexAttributeLocation = gl.getAttribLocation(program, name);
      // if it's under 0, it doesn't exist inside the program
      if (!(vertexAttributeLocation >= 0)) {
        throw new Error('failed to get the storage location of the attribute ' + name);
      }
      // 3f means like : 3 floating values
      // vertexAttrib[1...4]f are available
      // The vector versions of these methods are also available.
      // Their name contains “v” (vector),
      // and they take a typed array as a parameter.
      // The number in the method name indicates the number of elements in the array.
      // example:
      //  const position = new Float32Array([1.0, 2.0, 3.0, 1.0]);
      //  gl.vertexAttrib4fv(a_Position, position);
      switch (values.length) {
        case 1:
          gl.vertexAttrib1f(vertexAttributeLocation, values[0]);
          break;
        case 2:
          gl.vertexAttrib2f(vertexAttributeLocation, values[0], values[1]);
          break;
        case 3:
          gl.vertexAttrib3f(vertexAttributeLocation, values[0], values[1], values[2]);
          break;
        default:
        case 4:
          gl.vertexAttrib4f(vertexAttributeLocation, values[0], values[1], values[2], values[3]);
          break;
      }
      return vertexAttributeLocation;
    }
  before-each:
    const [canvas] = Refs.canvases as HTMLCanvasElement[];
    const gl = this.getWebGLContext(canvas as unknown as HTMLCanvasElement);
    const BASIC_BACKGROUND_COLOR: GLClearColorType = [0, 0, 0, 1];
    const vertices = new Float32Array([
      -0.5, -0.5,
      0.5, -0.5,
      0.0, 0,5,
    ]);
  default:
    this.setCanvasBackground(gl, BASIC_BACKGROUND_COLOR);
    // don't forget to set the gl_PointSize value
    // if you use an undefined attribute variable
    // the value will be replaced by 0.0
    const program = this.createProgram(gl, [
        `
      attribute vec4 positionAttr;
      void main() {
        gl_Position = positionAttr;
        gl_PointSize = 10.0;
      }
        `,
        `
      void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
      }`]);
    const positionAttr = gl.getAttribLocation(program, 'positionAttr');
    // save an event handler
    // before positionning a new point
    const points: number[] = [];
    (canvas as HTMLCanvasElement).addEventListener('mousemove', (event) => {
      const cnv: HTMLCanvasElement = canvas;
      const rect = cnv.getBoundingClientRect();
      let x = event.clientX;
      let y = event.clientY;

      x = ((x - rect.left) - (cnv.width / 2)) / (cnv.width / 2);
      y = ((cnv.height / 2) - (y - rect.top)) / (cnv.height / 2);
      points.push(x, y);
      this.count = points.length;
      // clear canvas;
      // background color should defined before anything
      // need to set the background before each draw
      this.setCanvasBackground(gl, BASIC_BACKGROUND_COLOR);
      for (let i = 0, a = points.length; i < a; i +=+ 2) {
        this.setVertexAttribute(gl, {
          program,
          name: 'positionAttr',
          values: [points[i], points[i+1], 0.0],
        });
        // only one program is usable
        // render the program
        let amount = 1;
        if (gl instanceof WebGLRenderingContext) {
          gl.drawArrays(gl.POINTS,
          // the first vertex is 0
          // this is the start for the program
          0,
          // the number of vertices
          amount);
        } else if (gl instanceof WebGL2RenderingContext) {
          gl.drawArraysInstanced(gl.POINTS, 0, amount, 1);
        }
      }
    });
    // create the shape with buffer
    // binding it with bindBuffer and bufferData right after
    // const buffer = this.createBufferWithVertices(gl, vertices);
    break;
</proto>
