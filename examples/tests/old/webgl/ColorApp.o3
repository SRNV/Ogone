import type { GLClearColorType, WebGLFusionType } from './public/types.ts';
// WebGL coordinates:
//   x: horizontal right direction is positive
//   y: vertical top direction is positive
//   z: depth line of sight is negative

// the attributes: width and height are required

// around > 1500 points
// there is a performance issue with mousemove and the for statement
// drawing each time the mouse move x points is not good for performances
// using requestAnimationFrame for draws solves the performance issue

// can't use attributes on a fragment shader
// fragment shader only accepts uniforms as properties
// vertex shader accepts attributes as properties
<template>
  <canvas
    width="500px"
    height="500px"
    ref="canvases" />
    <div>
      number of points: ${this.count}
    </div>
</template>
<proto
  type="app"
  base="./public">
  declare:
    count: number = 0;
    // create the animation service
    animationSet = new Set();
    saveAnimation(animation: Function) {
      this.animationSet.add(animation);
    }
    render() {
      for (let animate of this.animationSet) {
        (animate as Function)();
      }
    }
    delete(animation: Function) {
      this.animationSet.delete(animation);
    }
    clearAllAnimations() {
      this.animationSet.clear();
    }
    getWebGLContext(canvas: HTMLCanvasElement): WebGLFusionType | never {
        // need to get the correct webgl context
      const gl = canvas.getContext('webgl2')
        || canvas.getContext('webgl')
        || canvas.getContext('experimental-webgl');
      if (gl && (gl instanceof WebGLRenderingContext || gl instanceof WebGL2RenderingContext)) {
        console.log('Ogone - WebGL context retrieved');
      } else {
        throw new Error('Ogone is not able to get WebGL context, your browser or device may not support WebGL.')
      }
      return gl;
    }
    setCanvasBackground(gl: WebGLFusionType, color: GLClearColorType): void {
      // set the color of the background
      // a VXComponent can provide it with the attribute background
      gl.clearColor(...color); // RGBA
      // apply the clear color to get the result
      gl.clear(gl.COLOR_BUFFER_BIT);
    }
    createVertexShader(gl: WebGLFusionType, source: string,): any {
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      if (!vertexShader) throw new Error('Ogone - failed to vertex shader.');
      gl.shaderSource(vertexShader, source.trim());
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(vertexShader);
        throw new Error('failed to compile vertex shader.\n\n' + info);
      }
      return vertexShader;
    }
    createFragmentShader(gl: WebGLFusionType, source: string,): any {
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      if (!fragmentShader) throw new Error('Ogone - failed to create fragment shader.');
      gl.shaderSource(fragmentShader, source.trim());
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(fragmentShader);
        throw new Error('failed to compile fragment shader.\n\n' + info);
      }
      return fragmentShader;
    }
    createProgram(gl: WebGLFusionType, opts: [string, string] = ['', '']): WebGLProgram {
      // the variable gl_Position is required
      const vertexShader = this.createVertexShader(gl, opts[0]);
      const fragmentShader = this.createFragmentShader(gl, opts[1]);
      const program = gl.createProgram();
      if (!program) throw new Error('Ogone - failed to create program.');
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(fragmentShader);
        throw new Error('Ogone - failed to compile WebGL Program.\n\n' + info);
      }
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      if (!gl.getProgramParameter( program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program);
        throw new Error('Could not compile WebGL program. \n\n' + info);
      }
      // use the program defined before
      gl.validateProgram(program);
      gl.useProgram(program);
      return program;
    }

    createBufferWithVertices(gl: WebGLFusionType, vertices: Float32Array) {
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      return buffer;
    }
    setVertexAttribute(gl: WebGLFusionType, program: WebGLProgram, name: string, ...values: any[]) {
      // retrieve the attribute location of the attribute, in the program
      const vertexAttributeLocation = gl.getAttribLocation(program, name);
      // if it's under 0, it doesn't exist inside the program
      if (!(vertexAttributeLocation >= 0)) {
        throw new Error('failed to get the storage location of the attribute ' + name);
      }
      // 3f means like : 3 floating values
      // vertexAttrib[1...4]f are available
      // The vector versions of these methods are also available.
      // Their name contains “v” (vector),
      // and they take a typed array as a parameter.
      // The number in the method name indicates the number of elements in the array.
      // example:
      //  const position = new Float32Array([1.0, 2.0, 3.0, 1.0]);
      //  gl.vertexAttrib4fv(a_Position, position);
      switch (values.length) {
        case 1:
          gl.vertexAttrib1f(vertexAttributeLocation, values[0]);
          break;
        case 2:
          gl.vertexAttrib2f(vertexAttributeLocation, values[0], values[1]);
          break;
        case 3:
          gl.vertexAttrib3f(vertexAttributeLocation, values[0], values[1], values[2]);
          break;
        default:
        case 4:
          gl.vertexAttrib4f(vertexAttributeLocation, values[0], values[1], values[2], values[3]);
          break;
      }
      return vertexAttributeLocation;
    }
    getUniformLocation(gl: WebGLFusionType, program: WebGLProgram, name: string) {
      const uniform = gl.getUniformLocation(program, name);
      if (!uniform) {
        throw new Error(`Failed to get uniform location for the uniform: ${name}`);
      }
      return uniform;
    }
    setUniform(gl: WebGLFusionType, program: WebGLProgram, name: string, ...values: any[]) {
      const uniform = this.getUniformLocation(gl, program, name);
      switch (values.length) {
        case 1: gl.uniform1f(uniform, values[0]); break;
        case 2: gl.uniform2f(uniform, values[0], values[1]); break;
        case 3: gl.uniform3f(uniform, values[0], values[1], values[2]); break;
        default:
        case 4: gl.uniform4f(uniform, values[0], values[1], values[2], values[3]); break;
      }
      return uniform;
    }
  before-each:
    const [canvas] = Refs.canvases as HTMLCanvasElement[];
    const gl = this.getWebGLContext(canvas as unknown as HTMLCanvasElement);
    const BASIC_BACKGROUND_COLOR: GLClearColorType = [0, 0, 0, 1];
    const vertices = new Float32Array([
      -0.5, -0.5,
      0.5, -0.5,
      0.0, 0,5,
    ]);
  default:
    this.setCanvasBackground(gl, BASIC_BACKGROUND_COLOR);
    // don't forget to set the gl_PointSize value
    // if you use an undefined attribute variable
    // the value will be replaced by 0.0
    const program = this.createProgram(gl, [
        `
      attribute vec4 positionAttr;
      void main() {
        gl_Position = positionAttr;
        gl_PointSize = 10.0;
      }
        `,
        `
      precision mediump float;
      uniform vec4 colorUnif;
      void main() {
        gl_FragColor = colorUnif;
      }`]);
    // save an event handler
    // before positionning a new point
    const points: number[][] = [];
    const colors: number[][] = [];
    (canvas as HTMLCanvasElement).addEventListener('mousemove', (event) => {
      const cnv: HTMLCanvasElement = canvas;
      const rect = cnv.getBoundingClientRect();
      let x = event.clientX;
      let y = event.clientY;

      x = ((x - rect.left) - (cnv.width / 2)) / (cnv.width / 2);
      y = ((cnv.height / 2) - (y - rect.top)) / (cnv.height / 2);
      const point = [x, y];
      points.push(point);
      let r = 0, v = 0, b = 0;
      if (x < -0.5) {
        r = 0.3;
        v = 0.78;
        b = 0.12;
      } else if (x >= -0.5 && x < 0) {
        r = 0.08;
        v = 0.21;
        b = 0.99;
      } else if (x >= 0 && x < 0.5) {
        r = 0.3;
        v = 0.9;
        b = 0.5;
      } else {
        r = 1.0;
        v = 0.23;
        b = 0.56;
      }
      colors.push([r, v, b, 1.0]);
      this.count = points.length;
    });
    const listener = () => {
      // clear canvas;
      // background color should defined before anything
      // need to set the background before each draw
      this.setCanvasBackground(gl, BASIC_BACKGROUND_COLOR);
      for (let point of points) {
        const color = colors[points.indexOf(point)];
        this.setVertexAttribute(gl, program, 'positionAttr', ...point, 0.0);
        this.setUniform(gl, program, 'colorUnif', ...color);
        // only one program is usable
        // render the program
        let amount = 1;
        if (gl instanceof WebGLRenderingContext) {
          gl.drawArrays(gl.POINTS,
          // the first vertex is 0
          // this is the start for the program
          0,
          // the number of vertices
          amount);
        } else if (gl instanceof WebGL2RenderingContext) {
          gl.drawArraysInstanced(gl.POINTS, 0, amount, 1);
        }
      }
    };
    this.saveAnimation(listener);
    const animate = () => {
      this.render();
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    // create the shape with buffer
    // binding it with bindBuffer and bufferData right after
    // const buffer = this.createBufferWithVertices(gl, vertices);
    break;
</proto>
