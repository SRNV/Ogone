
<html>
  <head>
      
          <style>  h1[data-snroz], h2[data-snroz], h3[data-snroz], h4[data-snroz] {  color: #193b48;  }  .logo[data-snroz] {  flex: 2;  display: inline-flex;  flex-direction: row;  max-width: 124px;  min-width: 124px;  min-height: 65px;  }  .header[data-snroz] {  background: var(--o-header);  padding: 10px;  filter: drop-shadow(0px 10px 0px #00000087);  display: flex;  position: sticky;  top: 0px;  transition: top 0.5s ease;  overflow: hidden;  z-index: 500;  }  .title[data-snroz] {  margin: auto;  letter-spacing: 3px;  }    .container[data-5xo35] {  height: auto;  width: auto;  background: black;  animation-name: fade-in-right;  animation-iteration-count: 1;  animation-duration: 0.5s;  }    .container[data-ssxos] {  min-height: 400px;  width: 100%;  display: flex;  }  @media screen and (max-width: 965px) {  .container[data-ssxos] {  flex-direction: column;  }  }  .left[data-ssxos] {  background: var(--o-background);  flex: 6;  padding: 98px;  padding-left: 77px;  }  .right[data-ssxos] {  background: var(--o-black);  flex: 5;  padding: 53px;  padding-top: 135px;  padding-bottom: 135px;  }  .code[data-ssxos] {  white-space: pre;  }  .text[data-ssxos] {  color: var(--o-grey);  margin-left: 30px;  }  .title[data-ssxos] {  color: var(--o-dark-blue);  }    .container[data-xro3n] {  position: fixed;  top: 35%;  width: 40px;  height: 300px;  right: 0;  background: #2f3035;  border-radius: 5px 0 0 5px;  filter: drop-shadow(0px 2px 4px #00000086);  }    .img[data-nnb5y] {  width: auto;  }  .logo-back[data-nnb5y] {  background: var(--o-primary);  padding: 6px;  border-radius: 100%;  animation-name: fade-in-down;  animation-iteration-count: 1;  animation-duration: 1s;  }  .container[data-nnb5y] {  width: 60px;  height: auto;  }    .menu[data-yxynr] {  flex: 8;  display: flex;  flex-direction: row;  vertical-align: middle;  align-items: center;  justify-content: flex-end;  }   .line[data-5vn3y], .container[data-5vn3y] {  border-radius: 5px;  transition: filter 0.2s ease;  cursor: pointer; } .container[data-5vn3y] {  padding: 9px;  width: 28px;  height: auto;  background: var(--o-header);  display: flex;  flex-direction: column;  filter: drop-shadow(0px 0px 0px #00000045); } .container[data-5vn3y]:hover[data-5vn3y] {  filter: drop-shadow(0px 5px 3px #00000045); } .line[data-5vn3y] {  background: #848181;  margin-top: 2px;  margin-bottom: 2px;  height: 4px; } .container[data-5vn3y]:hover[data-5vn3y] .line[data-5vn3y] {  background: var(--o-primary); }    .container[data-ybryo] {  display: inline-flex;  background: var(--o-header);  height: 100%;  vertical-align: middle;  align-items: center;  padding: 23px;  text-transform: capitalize;  color: #afafaf;  cursor: pointer;  user-select: none; } .container[data-ybryo]:hover[data-ybryo] {  background: var(--o-primary);  color: var(--o-background); } .ok[data-ybryo], .in-progress[data-ybryo], .todo[data-ybryo] {  height: 3px;  width: 3px;  padding: 3px;  border-radius: 20px;  margin: 5px; } .ok[data-ybryo] {  background: var(--o-success) } .todo[data-ybryo] {  background: var(--o-error) } .in-progress[data-ybryo] {  background: var(--o-info) }    .container[data-vsrva] {  display: flex;  justify-content: center;  margin: auto;  flex-direction: column; } .logo[data-vsrva] {  width: 400px;  height: auto;  animation-name: rotate;  animation-duration: 5s;  animation-timing-function: ease;  animation-iteration-count: infinite;  animation-direction: alternate; } .text[data-vsrva] {  font-weight: 400;  font-size: 24pt;  text-align: center;  color: #9e9e9e;  margin: 40px; } .logo-back[data-vsrva] {  filter: drop-shadow(2px 4px 6px var(--o-primary));  background: var(--o-primary);  border-radius: 100%;  padding: 56px;  animation-name: popup;  animation-duration: 0.5s;  animation-timing-function: cubic-bezier(0.1, -0.6, 0.2, 0);  max-width: 500px;  margin: auto; }    .left-menu[data-xszxb] {  height: 100vh;  width: 300px;  min-width: 300px;  max-width: 300px;  position: fixed;  top: 0px;  transition: left 0.5s ease;  left: 0px;  background: var(--o-header);  z-index: 2000;  display: flex;  filter: drop-shadow(0px 0px 10px #000000);  flex-direction: column;  }  .close[data-xszxb] {  left: -100%;  }  .darken[data-xszxb] {  background: #00000090;  width: 100vw;  height: 100vh;  top: 0px;  left: 0px;  position: fixed;  z-index: 1999;  }  .header[data-xszxb] {  padding: 10px;  display: flex;  vertical-align: middle;  align-items: center;  justify-content: space-between;  border-bottom: 1px solid #4e4e4e;  }  .tree[data-xszxb] {  overflow-x: hidden;  overflow-y: auto;  }   .container[data-o5brr] {  color: var(--o-grey);  display: flex;  flex-direction: column;  flex: 1; } .child[data-o5brr] {  padding-left: 30px;  height: 0;  overflow: hidden;  transition: flex 0.5s ease;  background: #00000034; } .child-open[data-o5brr] {  flex: 1; } .title[data-o5brr] {  padding-bottom: 10px;  border-bottom: 1px solid #555;  padding: 5px;  cursor: pointer;  flex: 1;  display: flex;  justify-content: space-between; } .title[data-o5brr]:hover[data-o5brr] {  background: var(--o-primary);  color: white; } .child[data-o5brr] .title[data-o5brr] {  border-left: 1px solid #555; } .status[data-o5brr] {  display: list-item; } .ok[data-o5brr] {  color: var(--o-success) } .todo[data-o5brr] {  color: var(--o-error) } .in-progress[data-o5brr] {  color: var(--o-info) }   .container[data-ssvvo] {  overflow: hidden;  display: flex;  flex-direction: row-reverse; } .scrollbar[data-ssvvo] {  width: 9px;  flex: 1;  background: #3e3e3e; } .scrollbar-button[data-ssvvo] {  height: 20px;  width: 100%;  background: var(--o-grey); } .content[data-ssvvo] {  flex: 18; } .view[data-ssvvo] {  flex: 18;  overflow: auto; }    .img[data-xysby] {  width: auto;  }  .logo-back[data-xysby] {  background: var(--o-primary);  padding: 6px;  border-radius: 100%;  }  .container[data-xysby] {  width: 60px;  height: auto;  } </style>
          
  <link href="/public/style.css" rel="stylesheet"/>
  <link href="/public/animations.css" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.2/styles/night-owl.min.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto|Varela+Round" rel="stylesheet"></link>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.9.1/showdown.min.js"></script>
  
          <script>
            function OComponent() {
    this.key = null;
    this.data = null;
    this.dependencies = null;
    this.state = 0;
    this.activated = true;
    this.namespace = null;
    this.store = {};
    this.contexts = {
        for: {},
    };
    // for async context
    this.promises = [];
    this.resolve = null;
    this.async = {
        then: null,
        catch: null,
        finally: null,
    };
    this.dispatchAwait = null;
    this.promiseResolved = false;
    // events describers
    // this.events = {};
    // all nodes that's are dynamics will save a function into this property
    // like if we have
    //  <node --for="array as (el, i)" />
    // this node will register a function() { ... } that will be triggered each time there is an update
    //this.rerenderAsync = null;
    this.react = [];
    this.texts = [];
    this.childs = [];
    this.startLifecycle = (params, event) => {
        if (!this.activated)
            return;
        if (this.type === "store") {
            this.initStore();
        }
        // WIP
        Object.seal(this.data);
        this.runtime(0, params, event);
        this.state = 1; // component is rendered
    };
    this.update = (dependency) => {
        if (!this.activated)
            return;
        if (this.type === "store") {
            this.updateStore(dependency);
            return;
        }
        this.runtime(`update:${dependency}`);
        this.reactTo(dependency);
        this.renderTexts(dependency);
        this.childs.filter((c) => c.type !== "store").forEach((c) => {
            c.updateProps(dependency);
        });
    };
    this.renderTexts = (dependency) => {
        if (!this.activated)
            return;
        this.texts.forEach((t, i, arr) => {
            // if there is no update of the texts
            // this can be the reason why
            if (t && !t(dependency))
                delete arr[i];
        });
    };
    this.reactTo = (dependency) => {
        if (!this.activated)
            return;
        this.react.forEach((t, i, arr) => {
            if (t && !t(dependency))
                delete arr[i];
        });
    };
    this.initStore = () => {
        if (!Ogone.stores[this.namespace]) {
            Ogone.stores[this.namespace] = {
                ...this.data,
            };
        }
        // save the component's reaction into Ogone.clients with the key of the component
        // and a function
        Ogone.clients.push([this.key, (namespace, key, overwrite) => {
                if (namespace === this.namespace &&
                    this.data &&
                    this.parent &&
                    this.parent.data &&
                    key in this.parent.data) {
                    if (!overwrite) {
                        this.data[key] = Ogone.stores[this.namespace][key];
                    }
                    else {
                        Ogone.stores[this.namespace][key] = this.data[key];
                    }
                    this.parent.data[key] = this.data[key];
                    this.parent.update(key);
                }
                return true;
            }]);
    };
    this.updateStore = (dependency) => {
        // find the reaction of this store module with the key
        // @ts-ignore
        const [key, client] = Ogone.clients.find(([key]) => key === this.key);
        if (client) {
            // use the namespace, the dependency or property that should change
            // @ts-ignore
            client(this.namespace, dependency, true);
            // update other modules
            Ogone.clients.filter(([key]) => key !== this.key).forEach(([key, f], i, arr) => {
                if (f && !f(this.namespace, dependency, false)) {
                    delete arr[i];
                }
            });
        }
    };
    this.updateProps = (dependency) => {
        if (!this.activated)
            return;
        if (this.type === "store")
            return;
        if (!this.requirements || !this.props)
            return;
        this.requirements.forEach(([key, constructors]) => {
            const prop = this.props.find((prop) => prop[0] === key);
            const isAny = constructors.includes(null);
            if (!prop && !isAny) {
                const UndefinedPropertyForComponentException = `${key} is required as property but still undefined. Please use this syntax\n\t\t<component :${key}="..."></component>`;
                const err = new Error("[Ogone]  " + UndefinedPropertyForComponentException);
                Ogone.error(UndefinedPropertyForComponentException, `Undefined property ${key}. But ${key} is required in component`, err);
                throw err;
            }
            if (!prop)
                return;
            const value = this.parentContext({
                getText: `${prop[1]}`,
                position: this.positionInParentComponent,
            });
            if ((value === undefined || value === null) && !isAny) {
                const message = `${key} is required as property but can\'t be null. Please use this syntax\n\t\t<component :${key}="${constructors.join(" | ")}"></component>`;
                const NullishPropertyException = new Error("[Ogone]  " + message);
                Ogone.error(message, `Property ${key} can't be null for the component`, NullishPropertyException);
                throw NullishPropertyException;
            }
            if (!constructors.includes(value.constructor.name)) {
                const message = `${key} is required as property but it's value is not one of ${constructors.join(" | ")}
            evaluated value: ${prop[1]}
            constructor: ${value.constructor.name}`;
                const PropertyDontMatchWithConstructorsException = new Error("[Ogone] " + message);
                Ogone.error(message, `TypeError for property ${key}`, PropertyDontMatchWithConstructorsException);
                throw PropertyDontMatchWithConstructorsException;
            }
            if (this.data && value !== this.data[key]) {
                this.data[key] = value;
                this.update(key);
                if (this.type === "async") {
                    if (!this.dependencies)
                        return;
                    if (dependency &&
                        this.dependencies.find((d) => d.indexOf(dependency) > -1)) {
                        // let the user rerender
                        this.runtime("async:update", {
                            updatedParentProp: dependency,
                        });
                    }
                }
            }
        });
    };
    this.render = (Onode, /** original node */ opts) => {
        if (!Onode || !opts)
            return;
        // Onode is a web component
        // based on the user token
        // this web component is a custom Element
        // not an extension of an element cause the attr "is" is not dynamic
        // at the first call of this function Onode is not "rendered" (replaced by the required element)
        let { callingNewComponent, length: dataLength } = opts;
        typeof dataLength === "object" ? dataLength = 1 : [];
        const context = Onode.context;
        // no need to render if it's the same
        if (context.list.length === dataLength)
            return;
        let previousTemplate;
        // first we add missing nodes, we use cloneNode to generate the web-component
        for (let i = context.list.length, a = dataLength; i < a; i++) {
            let node;
            // @ts-ignore
            node = document.createElement(context.name, { is: Onode.extends });
            node.setOgone({
                index: i,
                originalNode: false,
                level: Onode.ogone.level,
                position: Onode.ogone.position.slice(),
                flags: Onode.ogone.flags,
                orinal: Onode,
                ...(!callingNewComponent ? { component: this } : {
                    props: Onode.ogone.props,
                    params: Onode.ogone.params,
                    parentComponent: Onode.ogone.parentComponent,
                    parentCTXId: Onode.ogone.parentCTXId,
                    positionInParentComponent: Onode.ogone.positionInParentComponent
                        .slice(),
                    levelInParentComponent: Onode.ogone.levelInParentComponent,
                }),
            });
            if (i === 0) {
                context.placeholder.replaceWith(node);
            }
            else {
                let lastEl = context.list[i - 1];
                if (lastEl && lastEl.isConnected) {
                    lastEl.insertElement("afterend", node);
                }
                else if (Onode && Onode.parentNode) {
                    Onode.parentNode.insertBefore(node, Onode.nextElementSibling);
                }
            }
            context.list.push(node);
            previousTemplate = node;
        }
        // no need to remove if it's the same
        if (context.list.length === dataLength)
            return;
        // now we remove the extra elements
        for (let i = context.list.length, a = dataLength; i > a; i--) {
            if (context.list.length === 1) {
                // get the first element of the webcomponent
                let firstEl = context.list[0];
                if (firstEl && firstEl.firstNode && firstEl.isConnected) {
                    firstEl.insertElement("beforebegin", context.placeholder);
                }
                else if (Onode.parentNode) {
                    const { parentNode } = context;
                    parentNode.insertBefore(context.placeholder, Onode);
                }
            }
            const rm = context.list.pop();
            // deactivate all the reactions of the component
            rm.removeNodes().remove();
        }
    };
    return this;
}
// @ts-ignore
const Ogone = {
    // store
    stores: {},
    clients: [],
    render: {},
    contexts: {},
    components: {},
    classes: {},
    errorPanel: null,
    warnPanel: null,
    successPanel: null,
    infosPanel: null,
    historyError: null,
    errors: 0,
    firstErrorPerf: null,
    sound: null,
    oscillator: null,
    error(message, errorType, errorObject) {
        // here we render the errors in development
        if (!this.errorPanel) {
            const p = document.createElement("div");
            const h = document.createElement("div");
            Object.entries({
                zIndex: "5000000",
                background: "#00000097",
                width: "100vw",
                height: "100vh",
                position: "fixed",
                overflowY: "auto",
                justifyContent: "center",
                display: "grid",
                flexDirection: "column",
            }).forEach(([key, value]) => p.style[key] = value);
            h.style.width = "100vw";
            h.style.position = "fixed";
            h.style.background = "black";
            h.style.bottom = "26px";
            h.style.height = "20px";
            h.style.left = "0px";
            h.style.zIndex = "50000000";
            this.errorPanel = p;
            this.errorPanel.append(h);
            this.historyError = h;
        }
        this.errors++;
        const err = document.createElement("div");
        Object.entries({
            zIndex: "5000000",
            background: "#000000",
            minHeight: "fit-content",
            maxWidth: "70%",
            padding: "21px",
            color: "red",
            borderLeft: "3px solid red",
            margin: "auto",
            display: "inline-flex",
            flexDirection: "column",
        }).forEach(([key, value]) => err.style[key] = value);
        const errorId = this.errors;
        const code = document.createElement("code");
        const stack = document.createElement("code");
        const h = document.createElement("h4");
        const errorPin = document.createElement("div");
        // set the text
        h.innerText = `[Ogone] Error ${errorId}: ${errorType ||
            "Undefined Type"}`;
        code.innerText = `${message.trim()}`;
        stack.innerText = `${
        // @ts-ignore
        errorObject && errorObject.stack
            ? // @ts-ignore
                errorObject.stack.replace(message, "")
            : ""}`;
        // check if stack is empty or not
        if (!stack.innerText.length && errorObject && errorObject.message) {
            stack.innerText = `${errorObject && errorObject.message ? errorObject.message : ""}`;
        }
        !stack.innerText.length ? stack.innerText = "undefined stack" : "";
        // set the styles
        code.style.marginLeft = "20px";
        code.style.whiteSpace = "pre-wrap";
        code.style.wordBreak = "break-word";
        stack.style.marginLeft = "20px";
        stack.style.color = "#dc7373";
        stack.style.padding = "17px";
        stack.style.background = "#462626";
        stack.style.whiteSpace = "pre-wrap";
        stack.style.wordBreak = "break-word";
        stack.style.border = "1px solid";
        stack.style.marginTop = "10px";
        h.style.color = "#8c8c8c";
        errorPin.style.background = "red";
        errorPin.style.width = "13px";
        errorPin.style.height = errorPin.style.width;
        errorPin.style.position = "fixed";
        errorPin.style.bottom = "30px";
        errorPin.style.zIndex = "50000000";
        const relativePinPosition = Math.round((this.firstErrorPerf / performance.now()) * 30) + 30;
        errorPin.style.left = this.firstErrorPerf
            ? `${relativePinPosition}px`
            : "30px";
        if (!this.firstErrorPerf) {
            this.firstErrorPerf = performance.now();
        }
        this.errorPanel.style.paddingTop = "30px";
        // set the grid of errors
        err.style.gridArea = `e${errorId}`;
        const m = 2;
        let grid = "";
        let i = 0;
        let a = 0;
        for (i = 0, a = this.errorPanel.childNodes.length + 1; i < a; i++) {
            grid += `e${i + 1} `;
        }
        let b = i;
        while (i % m) {
            grid += `e${b} `;
            i++;
        }
        const cells = grid.split(" ");
        var o, j, temparray, chunk = m;
        let newgrid = "";
        for (o = 0, j = cells.length - 1; o < j; o += chunk) {
            temparray = cells.slice(o, o + chunk);
            newgrid += ` "${temparray.join(" ")}"`;
        }
        this.errorPanel.style.gridGap = "10px";
        this.errorPanel.style.gridAutoRows = "max-content";
        this.errorPanel.style.gridTemplateAreas = newgrid;
        err.style.animationName = "popup";
        err.style.animationIterationCoutn = "1";
        err.style.animationDuration = "0.5s";
        // append elements
        err.append(h, code, stack);
        this.errorPanel.append(err);
        this.errorPanel.append(errorPin);
        this.errorPanel.style.pointerEvents = "scroll";
        //  append only if it's not in the document
        !this.errorPanel.isConnected
            ? document.body.append(this.errorPanel)
            : [];
    },
};
Ogone.router = {
    react: [],
    actualRoute: null,
    go: (url, state) => {
        if (!Ogone.router)
            return;
        if (Ogone.router.actualRoute === url)
            return;
        // protect from infinite loop
        Ogone.router.actualRoute = url;
        Ogone.router.react.forEach((r, i, arr) => {
            if (r && !r(url, state))
                delete arr[i];
        });
        // @ts-ignore
        history.pushState(state || {}, "", url || "/");
    },
};
// @ts-ignore
window.onpopstate = function (event) {
    // @ts-ignore
    Ogone.router.go(location.pathname, event.state);
};
Ogone.components['data-snroz'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "scrollY": 0 };
    this.refs = {};
    const Refs = this.refs;
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && ![].includes(_state)) {
                return;
            }
            switch (_state) {
                default:
                    const header = document.getElementById('header');
                    window.addEventListener('scroll', (ev) => {
                        if (window.scrollY > this.scrollY) {
                            header.style.top = '-100px';
                        }
                        else {
                            header.style.top = '0px';
                        }
                        this.scrollY = window.scrollY;
                        ____('scrollY', this);
                    });
                    break;
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/index.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-5xo35'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "articles": [{ "title": "Experimental tool for a fullstack use.", "text": "Ogone is an experimental tool for Fullstack dev. \nFully based on Deno.", "code": " o3.run({\n \tentrypoint: '/app/index.o3',\n \tport: 4000,\n })" }, { "title": "Get Started with the classic greeting app", "text": "TODO", "code": "<p>Hello ${name}</p>\n <proto>\n \tdef:\n \t\tname: Rudy\n </proto>" }, { "title": "Install Ogone", "text": "TODO", "code": "import o3 from \"https://deno.land/x/ogone/mod.ts\"" }, { "title": "Using case, default, def, before-each keywords to rule the component", "text": "TODO", "code": " <proto>\n \tdef:\n \t\tyaml: true\n \tcase 'update:yaml':\n \tdefault:\n \t\tthis.yaml = true;\n \tbreak;\n </proto>" }, { "title": "read def in yml files", "text": "TODO", "code": "<proto def=\"path/to/source.yml\"/>" }, { "title": "Default/Cases execution", "text": "TODO", "code": " <p>${count}</p>\n <button --click:increase>\n \tincrease\n </button>\n <proto>\n \tdef:\n \t\tcount:0\n \tcase 'click:increase':\n \t\tthis.count++;\n \t\tif (this.count > 5) execute default;\n \tbreak;\n \tdefault:\n \t\tthis.count = 0;\n \tbreak;\n </proto>" }] };
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-ssxos'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "title": null, "text": null, "code": null };
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-xro3n'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "test": null };
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-nnb5y'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = {};
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-yxynr'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "menu": [{ "name": "Docs", "route": "/doc", "status": "in-progress" }, { "name": "Api", "route": "/api", "status": "todo" }, { "name": "todos", "route": "/todos/testParams", "status": "todo" }, { "name": "project", "route": "/project", "status": "todo" }, { "name": "support", "route": "/support", "status": "todo" }] };
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-5vn3y'] = function () {
    OComponent.call(this);
    const Store = {
        dispatch: (id, ctx) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, action] = path;
                const mod = this.store[namespace];
                if (mod && mod.runtime) {
                    return mod.runtime(`action:${action}`, ctx)
                        .catch((err) => Ogone.error(err.message, `Error in dispatch. action: ${action} component: examples/app/components/burger.o3`, err));
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.runtime) {
                    return mod.runtime(`action:${id}`, ctx)
                        .catch((err) => Ogone.error(err.message, `Error in dispatch. action: ${action} component: examples/app/components/burger.o3`, err));
                }
            }
        },
        commit: (id, ctx) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, mutation] = path;
                const mod = this.store[namespace];
                if (mod && mod.runtime) {
                    return mod.runtime(`mutation:${mutation}`, ctx).catch((err) => Ogone.error(err.message, `Error in commit. mutation: ${mutation} component: examples/app/components/burger.o3`, err));
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.runtime) {
                    return mod.runtime(`mutation:${id}`, ctx).catch((err) => Ogone.error(err.message, `Error in commit. mutation: ${id} component: examples/app/components/burger.o3`, err));
                }
            }
        },
        get: (id) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, get] = path;
                const mod = this.store[namespace];
                if (mod && mod.data) {
                    return mod.data[get];
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.data) {
                    return mod.data[id];
                }
            }
        },
    };
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "isOpen": false };
    this.refs = {};
    const Refs = this.refs;
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && !['click:openMenu'].includes(_state)) {
                return;
            }
            switch (_state) {
                case 'click:openMenu':
                    Store.dispatch('menu/toggle');
                    break;
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/components/burger.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-yz5y5'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "isOpen": false };
    this.refs = {};
    const Refs = this.refs;
    const __run = (async function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && !['action:toggle'].includes(_state)) {
                return;
            }
            switch (_state) {
                case 'action:toggle':
                    this.isOpen = !this.isOpen;
                    ____('isOpen', this);
                    break;
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/stores/menu.store.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-ybryo'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "item": null };
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-nbbxb'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = {};
    this.refs = {};
    const Refs = this.refs;
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            switch (_state) {
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/routers/.router.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-vsrva'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = {};
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-xszxb'] = function () {
    OComponent.call(this);
    const Store = {
        dispatch: (id, ctx) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, action] = path;
                const mod = this.store[namespace];
                if (mod && mod.runtime) {
                    return mod.runtime(`action:${action}`, ctx)
                        .catch((err) => Ogone.error(err.message, `Error in dispatch. action: ${action} component: examples/app/components/menu/menu-main.o3`, err));
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.runtime) {
                    return mod.runtime(`action:${id}`, ctx)
                        .catch((err) => Ogone.error(err.message, `Error in dispatch. action: ${action} component: examples/app/components/menu/menu-main.o3`, err));
                }
            }
        },
        commit: (id, ctx) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, mutation] = path;
                const mod = this.store[namespace];
                if (mod && mod.runtime) {
                    return mod.runtime(`mutation:${mutation}`, ctx).catch((err) => Ogone.error(err.message, `Error in commit. mutation: ${mutation} component: examples/app/components/menu/menu-main.o3`, err));
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.runtime) {
                    return mod.runtime(`mutation:${id}`, ctx).catch((err) => Ogone.error(err.message, `Error in commit. mutation: ${id} component: examples/app/components/menu/menu-main.o3`, err));
                }
            }
        },
        get: (id) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, get] = path;
                const mod = this.store[namespace];
                if (mod && mod.data) {
                    return mod.data[get];
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.data) {
                    return mod.data[id];
                }
            }
        },
    };
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "isOpen": false, "menu": [{ "name": "Introduction", "route": "/intro" }, { "name": "Ogone theory", "route": "/theory" }, { "name": "Documentation", "route": "/doc", "children": [{ "name": "Install", "route": "/doc/install" }, { "name": "Get Started", "route": "/doc/get-started" }, { "name": "Flags", "route": "/flags", "children": [{ "name": "--if --else --else-if", "status": "ok" }, { "name": "--for", "status": "ok" }, { "name": "--await --defer", "status": "in-progress" }, { "name": "--then:...", "status": "ok" }, { "name": "--catch:...", "status": "ok" }, { "name": "--finally:...", "status": "ok" }, { "name": "--class --style", "status": "ok" }, { "name": "--anim", "status": "todo" }, { "name": "--router-go", "status": "ok" }, { "name": "--<DOM L3>:..", "status": "ok" }, { "name": "--drag:...", "status": "todo" }, { "name": "--dragstart:...", "status": "todo" }, { "name": "--dragend:...", "status": "todo" }] }, { "name": "Components", "route": "/doc/components", "status": "ok", "children": [{ "name": "Components Anatomy", "route": "/doc/components/components-anatomy" }, { "name": "Counter", "route": "/doc/components/counter" }, { "name": "Greeting App", "route": "/doc/components/cgc" }, { "name": "Recursive Tree Button", "route": "/doc/components/rtb" }] }, { "name": "Async Components", "status": "in-progress", "route": "/doc/async-components" }, { "name": "Router", "route": "/doc/router", "status": "in-progress", "children": [{ "name": "Router anatomy", "route": "/doc/router/router-anatomy" }] }, { "name": "Store", "status": "in-progress", "route": "/doc/store", "children": [{ "name": "Store anatomy", "route": "/doc/store/store-anatomy" }] }, { "name": "Controllers", "status": "in-progress", "route": "/doc/controllers", "children": [{ "name": "Controllers anatomy", "route": "/doc/controllers/controllers-anatomy" }] }, { "name": "Api", "route": "/api", "children": [{ "name": "Refs", "status": "in-progress" }, { "name": "Store", "status": "in-progress" }, { "name": "Async", "status": "in-progress" }, { "name": "Tests Cases", "status": "todo" }] }] }, { "name": "Project", "route": "/project" }, { "name": "Todos", "route": "/todos" }, { "name": "Support", "route": "/support" }] };
    this.refs = {};
    const Refs = this.refs;
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && !['click:toggle-menu'].includes(_state)) {
                return;
            }
            switch (_state) {
                case 'click:toggle-menu':
                    Store.dispatch('menu/toggle');
                    break;
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/components/menu/menu-main.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-o5brr'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "openTree": false, "item": null };
    this.refs = {};
    const Refs = this.refs;
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && !['click:toggle'].includes(_state)) {
                return;
            }
            switch (_state) {
                case 'click:toggle':
                    this.openTree = !this.openTree;
                    ____('openTree', this);
                    break;
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/components/menu/tree-recursive-button.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-ssvvo'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = {};
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-xysby'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = {};
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.render['data-snroz-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-snroz', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('div'); if (position)
    position[level] = index; n4.setAttribute('data-snroz', ''); n4.setAttribute('id', 'header'); n4.setAttribute('class', 'header'); n4.append((function (ctx, position = [], index = 0, level = 0) { const n5 = document.createElement('div'); if (position)
    position[level] = index; n5.setAttribute('data-snroz', ''); n5.setAttribute('class', 'logo'); n5.append((function (ctx, position = [], index = 0, level = 0) { const nd6 = document.createElement('template', { is: 'data-nnb5y-nt' }); if (position)
    position[level] = index; nd6.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-snroz-nd6', dependencies: ["'/'"], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "name": "router-go", "eval": "'/'" }], "elseIf": "", "finally": "", "else": false }, }); nd6.setAttribute('data-snroz', ''); return nd6; })(ctx, position.slice(), index, level + 1)); return n5; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n9 = document.createElement('template', { is: 'data-yxynr-nt' }); if (position)
    position[level] = index; n9.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-snroz-n9', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n9.setAttribute('data-snroz', ''); return n9; })(ctx, position.slice(), index, level + 1)); return n4; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n11 = document.createElement('template', { is: 'data-nbbxb-nt' }); if (position)
    position[level] = index; n11.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-snroz-n11', dependencies: ["new"], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n11.setAttribute('data-snroz', ''); n11.setAttribute('name', 'new'); return n11; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n12 = document.createElement('template', { is: 'data-xszxb-nt' }); if (position)
    position[level] = index; n12.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-snroz-n12', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n12.setAttribute('data-snroz', ''); return n12; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd13 = document.createElement('template', { is: 'data-xro3n-nt' }); if (position)
    position[level] = index; nd13.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-snroz-nd13', dependencies: ["scrollY"], props: ([["test", "scrollY"]]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd13.setAttribute('data-snroz', ''); return nd13; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-5xo35-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-5xo35', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-5xo35', ''); n3.setAttribute('class', 'container'); n3.append((function (ctx, position = [], index = 0, level = 0) { const nd4 = document.createElement('template', { is: 'data-ssxos-nt' }); if (position)
    position[level] = index; nd4.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-5xo35-nd4', dependencies: ["articles as (article)", "article.text", "article.title", "article.code"], props: ([["text", "article.text"], ["title", "article.title"], ["code", "article.code"]]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd4.setAttribute('data-5xo35', ''); return nd4; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-ssxos-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-ssxos', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-ssxos', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-ssxos', ''); n3.setAttribute('class', 'left'); n3.append((function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('h2'); if (position)
    position[level] = index; n4.setAttribute('data-ssxos', ''); n4.setAttribute('class', 'title'); n4.append((function (ctx, position = [], index = 0, level = 0) { const t10 = new Text(' '); const g = Ogone.contexts['data-ssxos-t10'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${title}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t10.data && t10.data !== v)
    t10.data = v; return true; } ; ctx.texts.push(r); return t10; })(ctx, position.slice())); return n4; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('p'); if (position)
    position[level] = index; n6.setAttribute('data-ssxos', ''); n6.setAttribute('class', 'text'); n6.append((function (ctx, position = [], index = 0, level = 0) { const t15 = new Text(' '); const g = Ogone.contexts['data-ssxos-t15'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${text}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t15.data && t15.data !== v)
    t15.data = v; return true; } ; ctx.texts.push(r); return t15; })(ctx, position.slice())); return n6; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n9 = document.createElement('div'); if (position)
    position[level] = index; n9.setAttribute('data-ssxos', ''); n9.setAttribute('class', 'right'); n9.append((function (ctx, position = [], index = 0, level = 0) { const n10 = document.createElement('pre'); if (position)
    position[level] = index; n10.setAttribute('data-ssxos', ''); n10.append((function (ctx, position = [], index = 0, level = 0) { const n11 = document.createElement('code'); if (position)
    position[level] = index; n11.setAttribute('data-ssxos', ''); n11.append((function (ctx, position = [], index = 0, level = 0) { const t26 = new Text(' '); const g = Ogone.contexts['data-ssxos-t26'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${code}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t26.data && t26.data !== v)
    t26.data = v; return true; } ; ctx.texts.push(r); return t26; })(ctx, position.slice())); return n11; })(ctx, position.slice(), index, level + 1)); return n10; })(ctx, position.slice(), index, level + 1)); return n9; })(ctx, position.slice(), index, level + 1)); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-xro3n-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-xro3n', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-xro3n', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const t6 = new Text(' '); const g = Ogone.contexts['data-xro3n-t6'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${test}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t6.data && t6.data !== v)
    t6.data = v; return true; } ; ctx.texts.push(r); return t6; })(ctx, position.slice())); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-nnb5y-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-nnb5y', ''); nt.append((function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-nnb5y', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-nnb5y', ''); n3.setAttribute('class', 'logo-back'); n3.append((function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('img'); if (position)
    position[level] = index; n4.setAttribute('data-nnb5y', ''); n4.setAttribute('class', 'img'); n4.setAttribute('src', '/public/ogone.svg'); return n4; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1)); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-yxynr-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-yxynr', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-yxynr', ''); n3.setAttribute('id', 'test'); n3.setAttribute('class', 'menu'); n3.append((function (ctx, position = [], index = 0, level = 0) { const nd4 = document.createElement('template', { is: 'data-ybryo-nt' }); if (position)
    position[level] = index; nd4.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-yxynr-nd4', dependencies: ["menu as (t)", "t"], props: ([["item", "t"]]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd4.setAttribute('data-yxynr', ''); return nd4; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n5 = document.createElement('div'); if (position)
    position[level] = index; n5.setAttribute('data-yxynr', ''); n5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('template', { is: 'data-5vn3y-nt' }); if (position)
    position[level] = index; n6.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-yxynr-n6', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n6.setAttribute('data-yxynr', ''); return n6; })(ctx, position.slice(), index, level + 1)); return n5; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-5vn3y-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-5vn3y', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('template', { is: 'data-yz5y5-nt' }); if (position)
    position[level] = index; n2.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-5vn3y-n2', dependencies: ["menu"], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n2.setAttribute('data-5vn3y', ''); n2.setAttribute('namespace', 'menu'); return n2; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement("data-5vn3y-nd5"); if (position)
    position[level] = index; nd5.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "case": "click:openMenu", "filter": null, "target": null }], "elseIf": "", "finally": "", "else": false }, }); nd5.setAttribute('data-5vn3y', ''); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('div'); if (position)
    position[level] = index; n6.setAttribute('data-5vn3y', ''); n6.setAttribute('class', 'line'); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n8 = document.createElement('div'); if (position)
    position[level] = index; n8.setAttribute('data-5vn3y', ''); n8.setAttribute('class', 'line'); return n8; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n10 = document.createElement('div'); if (position)
    position[level] = index; n10.setAttribute('data-5vn3y', ''); n10.setAttribute('class', 'line'); return n10; })(ctx, position.slice(), index, level + 1)); return nd5; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-5vn3y-nd5'] = (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement('div'); if (position)
    position[level] = index; nd5.setAttribute('data-5vn3y', ''); nd5.setAttribute('class', 'container'); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('div'); if (position)
    position[level] = index; n6.setAttribute('data-5vn3y', ''); n6.setAttribute('class', 'line'); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n8 = document.createElement('div'); if (position)
    position[level] = index; n8.setAttribute('data-5vn3y', ''); n8.setAttribute('class', 'line'); return n8; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n10 = document.createElement('div'); if (position)
    position[level] = index; n10.setAttribute('data-5vn3y', ''); n10.setAttribute('class', 'line'); return n10; })(ctx, position.slice(), index, level + 1)); return nd5; });
Ogone.render['data-yz5y5-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-yz5y5', ''); return nt; });
Ogone.render['data-ybryo-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-ybryo', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const nd2 = document.createElement("data-ybryo-nd2"); if (position)
    position[level] = index; nd2.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "name": "router-go", "eval": "item.route" }], "elseIf": "", "finally": "", "else": false }, }); nd2.setAttribute('data-ybryo', ''); nd2.append((function (ctx, position = [], index = 0, level = 0) { const t6 = new Text(' '); const g = Ogone.contexts['data-ybryo-t6'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${item.name}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t6.data && t6.data !== v)
    t6.data = v; return true; } ; ctx.texts.push(r); return t6; })(ctx, position.slice()), (function (ctx, position = [], index = 0, level = 0) { const nd3 = document.createElement("data-ybryo-nd3"); if (position)
    position[level] = index; nd3.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'ok'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd3.setAttribute('data-ybryo', ''); return nd3; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement("data-ybryo-nd5"); if (position)
    position[level] = index; nd5.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'todo'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd5.setAttribute('data-ybryo', ''); return nd5; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd7 = document.createElement("data-ybryo-nd7"); if (position)
    position[level] = index; nd7.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'in-progress'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd7.setAttribute('data-ybryo', ''); return nd7; })(ctx, position.slice(), index, level + 1)); return nd2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-ybryo-nd2'] = (function (ctx, position = [], index = 0, level = 0) { const nd2 = document.createElement('div'); if (position)
    position[level] = index; nd2.setAttribute('data-ybryo', ''); nd2.setAttribute('class', 'container'); nd2.append((function (ctx, position = [], index = 0, level = 0) { const t6 = new Text(' '); const g = Ogone.contexts['data-ybryo-t6'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${item.name}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t6.data && t6.data !== v)
    t6.data = v; return true; } ; ctx.texts.push(r); return t6; })(ctx, position.slice()), (function (ctx, position = [], index = 0, level = 0) { const nd3 = document.createElement("data-ybryo-nd3"); if (position)
    position[level] = index; nd3.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'ok'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd3.setAttribute('data-ybryo', ''); return nd3; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement("data-ybryo-nd5"); if (position)
    position[level] = index; nd5.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'todo'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd5.setAttribute('data-ybryo', ''); return nd5; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd7 = document.createElement("data-ybryo-nd7"); if (position)
    position[level] = index; nd7.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'in-progress'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd7.setAttribute('data-ybryo', ''); return nd7; })(ctx, position.slice(), index, level + 1)); return nd2; });
Ogone.render['data-ybryo-nd3'] = (function (ctx, position = [], index = 0, level = 0) { const nd3 = document.createElement('span'); if (position)
    position[level] = index; nd3.setAttribute('data-ybryo', ''); nd3.setAttribute('class', 'ok'); return nd3; });
Ogone.render['data-ybryo-nd5'] = (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement('span'); if (position)
    position[level] = index; nd5.setAttribute('data-ybryo', ''); nd5.setAttribute('class', 'todo'); return nd5; });
Ogone.render['data-ybryo-nd7'] = (function (ctx, position = [], index = 0, level = 0) { const nd7 = document.createElement('span'); if (position)
    position[level] = index; nd7.setAttribute('data-ybryo', ''); nd7.setAttribute('class', 'in-progress'); return nd7; });
Ogone.render['data-nbbxb-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-nbbxb', ''); nt.append(``); return nt; });
Ogone.render['data-vsrva-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-vsrva', ''); nt.append((function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-vsrva', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-vsrva', ''); n3.setAttribute('class', 'logo-back'); n3.append((function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('img'); if (position)
    position[level] = index; n4.setAttribute('data-vsrva', ''); n4.setAttribute('class', 'logo'); n4.setAttribute('src', '/public/ogone.svg'); return n4; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('div'); if (position)
    position[level] = index; n6.setAttribute('data-vsrva', ''); n6.setAttribute('class', 'text'); n6.append(`404 route not found.`); return n6; })(ctx, position.slice(), index, level + 1)); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-xszxb-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-xszxb', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('template', { is: 'data-yz5y5-nt' }); if (position)
    position[level] = index; n2.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-xszxb-n2', dependencies: ["menu"], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n2.setAttribute('data-xszxb', ''); n2.setAttribute('namespace', 'menu'); return n2; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement("data-xszxb-nd5"); if (position)
    position[level] = index; nd5.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "{ close: !isOpen }", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd5.setAttribute('data-xszxb', ''); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('div'); if (position)
    position[level] = index; n6.setAttribute('data-xszxb', ''); n6.setAttribute('class', 'header'); n6.append((function (ctx, position = [], index = 0, level = 0) { const nd7 = document.createElement('template', { is: 'data-xysby-nt' }); if (position)
    position[level] = index; nd7.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-xszxb-nd7', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "case": "click:toggle-menu", "filter": null, "target": null }], "elseIf": "", "finally": "", "else": false }, }); nd7.setAttribute('data-xszxb', ''); return nd7; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n9 = document.createElement('div'); if (position)
    position[level] = index; n9.setAttribute('data-xszxb', ''); n9.append(`0.1.0`); return n9; })(ctx, position.slice(), index, level + 1)); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n12 = document.createElement('div'); if (position)
    position[level] = index; n12.setAttribute('data-xszxb', ''); n12.setAttribute('class', 'tree'); n12.append((function (ctx, position = [], index = 0, level = 0) { const nd13 = document.createElement('template', { is: 'data-o5brr-nt' }); if (position)
    position[level] = index; nd13.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-xszxb-nd13', dependencies: ["menu as (item)", "item"], props: ([["item", "item"]]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd13.setAttribute('data-xszxb', ''); return nd13; })(ctx, position.slice(), index, level + 1)); return n12; })(ctx, position.slice(), index, level + 1)); return nd5; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd17 = document.createElement("data-xszxb-nd17"); if (position)
    position[level] = index; nd17.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "{ darken: isOpen }", "catch": "", "events": [{ "type": "click", "case": "click:toggle-menu", "filter": null, "target": null }], "elseIf": "", "finally": "", "else": false }, }); nd17.setAttribute('data-xszxb', ''); return nd17; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-xszxb-nd5'] = (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement('div'); if (position)
    position[level] = index; nd5.setAttribute('data-xszxb', ''); nd5.setAttribute('class', 'left-menu'); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('div'); if (position)
    position[level] = index; n6.setAttribute('data-xszxb', ''); n6.setAttribute('class', 'header'); n6.append((function (ctx, position = [], index = 0, level = 0) { const nd7 = document.createElement('template', { is: 'data-xysby-nt' }); if (position)
    position[level] = index; nd7.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-xszxb-nd7', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "case": "click:toggle-menu", "filter": null, "target": null }], "elseIf": "", "finally": "", "else": false }, }); nd7.setAttribute('data-xszxb', ''); return nd7; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n9 = document.createElement('div'); if (position)
    position[level] = index; n9.setAttribute('data-xszxb', ''); n9.append(`0.1.0`); return n9; })(ctx, position.slice(), index, level + 1)); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n12 = document.createElement('div'); if (position)
    position[level] = index; n12.setAttribute('data-xszxb', ''); n12.setAttribute('class', 'tree'); n12.append((function (ctx, position = [], index = 0, level = 0) { const nd13 = document.createElement('template', { is: 'data-o5brr-nt' }); if (position)
    position[level] = index; nd13.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-xszxb-nd13', dependencies: ["menu as (item)", "item"], props: ([["item", "item"]]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd13.setAttribute('data-xszxb', ''); return nd13; })(ctx, position.slice(), index, level + 1)); return n12; })(ctx, position.slice(), index, level + 1)); return nd5; });
Ogone.render['data-xszxb-nd17'] = (function (ctx, position = [], index = 0, level = 0) { const nd17 = document.createElement('div'); if (position)
    position[level] = index; nd17.setAttribute('data-xszxb', ''); return nd17; });
Ogone.render['data-o5brr-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-o5brr', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('div'); if (position)
    position[level] = index; n4.setAttribute('data-o5brr', ''); n4.setAttribute('class', 'container'); n4.append((function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement("data-o5brr-nd5"); if (position)
    position[level] = index; nd5.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "case": "click:toggle", "filter": null, "target": null }, { "type": "click", "name": "router-go", "eval": "item.route" }], "elseIf": "", "finally": "", "else": false }, }); nd5.setAttribute('data-o5brr', ''); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('span'); if (position)
    position[level] = index; n6.setAttribute('data-o5brr', ''); n6.append((function (ctx, position = [], index = 0, level = 0) { const t15 = new Text(' '); const g = Ogone.contexts['data-o5brr-t15'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${item.name}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t15.data && t15.data !== v)
    t15.data = v; return true; } ; ctx.texts.push(r); return t15; })(ctx, position.slice())); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd8 = document.createElement("data-o5brr-nd8"); if (position)
    position[level] = index; nd8.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "!item.children && item.status ? `status ${item.status}` : ''", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd8.setAttribute('data-o5brr', ''); nd8.append((function (ctx, position = [], index = 0, level = 0) { const t20 = new Text(' '); const g = Ogone.contexts['data-o5brr-t20'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${!item.children && item.status ? item.status : \'\'}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t20.data && t20.data !== v)
    t20.data = v; return true; } ; ctx.texts.push(r); return t20; })(ctx, position.slice())); return nd8; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd10 = document.createElement("data-o5brr-nd10"); if (position)
    position[level] = index; nd10.setOgone({ position, level, index, component: ctx, flags: { "if": "item.children && !openTree", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd10.setAttribute('data-o5brr', ''); nd10.append(`>`); return nd10; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd12 = document.createElement("data-o5brr-nd12"); if (position)
    position[level] = index; nd12.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "item.children && openTree", "finally": "", "else": false }, }); nd12.setAttribute('data-o5brr', ''); nd12.append(`<`); return nd12; })(ctx, position.slice(), index, level + 1)); return nd5; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd15 = document.createElement("data-o5brr-nd15"); if (position)
    position[level] = index; nd15.setOgone({ position, level, index, component: ctx, flags: { "if": "item.children", "then": "", "defer": "", "await": "", "style": "", "class": "{ 'child-open': openTree }", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd15.setAttribute('data-o5brr', ''); nd15.append((function (ctx, position = [], index = 0, level = 0) { const n16 = document.createElement('template', { is: 'data-ssvvo-nt' }); if (position)
    position[level] = index; n16.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-o5brr-n16', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n16.setAttribute('data-o5brr', ''); n16.append((function (ctx, position = [], index = 0, level = 0) { const nd17 = document.createElement('template', { is: 'data-o5brr-nt' }); if (position)
    position[level] = index; nd17.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-o5brr-nd17', dependencies: ["!!item.children", "item.children as (child)", "child ? child : {}"], props: ([["item", "child ? child : {}"]]), flags: { "if": "!!item.children", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd17.setAttribute('data-o5brr', ''); return nd17; })(ctx, position.slice(), index, level + 1)); return n16; })(ctx, position.slice(), index, level + 1)); return nd15; })(ctx, position.slice(), index, level + 1)); return n4; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-o5brr-nd5'] = (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement('div'); if (position)
    position[level] = index; nd5.setAttribute('data-o5brr', ''); nd5.setAttribute('class', 'title'); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('span'); if (position)
    position[level] = index; n6.setAttribute('data-o5brr', ''); n6.append((function (ctx, position = [], index = 0, level = 0) { const t15 = new Text(' '); const g = Ogone.contexts['data-o5brr-t15'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${item.name}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t15.data && t15.data !== v)
    t15.data = v; return true; } ; ctx.texts.push(r); return t15; })(ctx, position.slice())); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd8 = document.createElement("data-o5brr-nd8"); if (position)
    position[level] = index; nd8.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "!item.children && item.status ? `status ${item.status}` : ''", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd8.setAttribute('data-o5brr', ''); nd8.append((function (ctx, position = [], index = 0, level = 0) { const t20 = new Text(' '); const g = Ogone.contexts['data-o5brr-t20'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${!item.children && item.status ? item.status : \'\'}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t20.data && t20.data !== v)
    t20.data = v; return true; } ; ctx.texts.push(r); return t20; })(ctx, position.slice())); return nd8; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd10 = document.createElement("data-o5brr-nd10"); if (position)
    position[level] = index; nd10.setOgone({ position, level, index, component: ctx, flags: { "if": "item.children && !openTree", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd10.setAttribute('data-o5brr', ''); nd10.append(`>`); return nd10; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd12 = document.createElement("data-o5brr-nd12"); if (position)
    position[level] = index; nd12.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "item.children && openTree", "finally": "", "else": false }, }); nd12.setAttribute('data-o5brr', ''); nd12.append(`<`); return nd12; })(ctx, position.slice(), index, level + 1)); return nd5; });
Ogone.render['data-o5brr-nd8'] = (function (ctx, position = [], index = 0, level = 0) { const nd8 = document.createElement('span'); if (position)
    position[level] = index; nd8.setAttribute('data-o5brr', ''); nd8.append((function (ctx, position = [], index = 0, level = 0) { const t20 = new Text(' '); const g = Ogone.contexts['data-o5brr-t20'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${!item.children && item.status ? item.status : \'\'}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t20.data && t20.data !== v)
    t20.data = v; return true; } ; ctx.texts.push(r); return t20; })(ctx, position.slice())); return nd8; });
Ogone.render['data-o5brr-nd10'] = (function (ctx, position = [], index = 0, level = 0) { const nd10 = document.createElement('span'); if (position)
    position[level] = index; nd10.setAttribute('data-o5brr', ''); nd10.append(`>`); return nd10; });
Ogone.render['data-o5brr-nd12'] = (function (ctx, position = [], index = 0, level = 0) { const nd12 = document.createElement('span'); if (position)
    position[level] = index; nd12.setAttribute('data-o5brr', ''); nd12.append(`<`); return nd12; });
Ogone.render['data-o5brr-nd15'] = (function (ctx, position = [], index = 0, level = 0) { const nd15 = document.createElement('div'); if (position)
    position[level] = index; nd15.setAttribute('data-o5brr', ''); nd15.setAttribute('class', 'child'); nd15.append((function (ctx, position = [], index = 0, level = 0) { const n16 = document.createElement('template', { is: 'data-ssvvo-nt' }); if (position)
    position[level] = index; n16.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-o5brr-n16', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n16.setAttribute('data-o5brr', ''); n16.append((function (ctx, position = [], index = 0, level = 0) { const nd17 = document.createElement('template', { is: 'data-o5brr-nt' }); if (position)
    position[level] = index; nd17.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-o5brr-nd17', dependencies: ["!!item.children", "item.children as (child)", "child ? child : {}"], props: ([["item", "child ? child : {}"]]), flags: { "if": "!!item.children", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd17.setAttribute('data-o5brr', ''); return nd17; })(ctx, position.slice(), index, level + 1)); return n16; })(ctx, position.slice(), index, level + 1)); return nd15; });
Ogone.render['data-ssvvo-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-ssvvo', ''); nt.append((function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-ssvvo', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-ssvvo', ''); ctx.refs['view'] = n3; n3.setAttribute('class', 'view'); n3.append((function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('div'); if (position)
    position[level] = index; n4.setAttribute('data-ssvvo', ''); ctx.refs['content'] = n4; n4.setAttribute('class', 'content'); n4.append((function (ctx, position = [], index = 0, level = 0) { const n5 = document.createElement('slot'); if (position)
    position[level] = index; n5.setAttribute('data-ssvvo', ''); return n5; })(ctx, position.slice(), index, level + 1)); return n4; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1)); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-xysby-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-xysby', ''); nt.append((function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-xysby', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-xysby', ''); n3.setAttribute('class', 'logo-back'); n3.append((function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('img'); if (position)
    position[level] = index; n4.setAttribute('data-xysby', ''); n4.setAttribute('class', 'img'); n4.setAttribute('src', '/public/ogone.svg'); return n4; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1)); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.contexts['data-xysby-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/logo.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return {};
};
Ogone.contexts['data-xysby-n2'] = Ogone.contexts['data-xysby-nt'];
Ogone.contexts['data-xysby-n3'] = Ogone.contexts['data-xysby-n2'];
Ogone.contexts['data-xysby-n4'] = Ogone.contexts['data-xysby-n3'];
Ogone.contexts['data-ssvvo-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/scroll.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return {};
};
Ogone.contexts['data-ssvvo-n2'] = Ogone.contexts['data-ssvvo-nt'];
Ogone.contexts['data-ssvvo-n3'] = Ogone.contexts['data-ssvvo-n2'];
Ogone.contexts['data-ssvvo-n4'] = Ogone.contexts['data-ssvvo-n3'];
Ogone.contexts['data-ssvvo-n5'] = Ogone.contexts['data-ssvvo-n4'];
Ogone.contexts['data-o5brr-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-o5brr-n4'] = Ogone.contexts['data-o5brr-nt'];
Ogone.contexts['data-o5brr-nd15'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_LENGTH && !(item.children)) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-o5brr-n16'] = Ogone.contexts['data-o5brr-nd15'];
Ogone.contexts['data-o5brr-nd17'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    const _____a_ = item.children || [];
    let i2 = POSITION[4], child = (_____a_)[i2];
    let _____a_2 = _____a_.filter((child, i2) => (!!item.children));
    child = (_____a_2)[i2];
    if (GET_LENGTH) {
        return (_____a_2).length;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { i2, child, openTree, item };
};
Ogone.contexts['data-o5brr-nd5'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-o5brr-nd12'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_LENGTH && (item.children && !openTree)) {
        return 0;
    }
    else if (GET_LENGTH && !(item.children && openTree)) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-o5brr-t30'] = Ogone.contexts['data-o5brr-nd12'];
Ogone.contexts['data-o5brr-nd10'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_LENGTH && !(item.children && !openTree)) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-o5brr-t25'] = Ogone.contexts['data-o5brr-nd10'];
Ogone.contexts['data-o5brr-nd8'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-o5brr-t20'] = Ogone.contexts['data-o5brr-nd8'];
Ogone.contexts['data-o5brr-n6'] = Ogone.contexts['data-o5brr-nd5'];
Ogone.contexts['data-o5brr-t15'] = Ogone.contexts['data-o5brr-n6'];
Ogone.contexts['data-o5brr-t3'] = Ogone.contexts['data-o5brr-nt'];
Ogone.contexts['data-xszxb-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    const menu = this.menu;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-main.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen, menu };
};
Ogone.contexts['data-xszxb-nd17'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    const menu = this.menu;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-main.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen, menu };
};
Ogone.contexts['data-xszxb-nd5'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    const menu = this.menu;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-main.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen, menu };
};
Ogone.contexts['data-xszxb-n12'] = Ogone.contexts['data-xszxb-nd5'];
Ogone.contexts['data-xszxb-nd13'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    const menu = this.menu;
    const _____a_ = menu || [];
    let i1 = POSITION[3], item = (_____a_)[i1];
    if (GET_LENGTH) {
        return (_____a_).length;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-main.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { i1, item, isOpen, menu };
};
Ogone.contexts['data-xszxb-n6'] = Ogone.contexts['data-xszxb-nd5'];
Ogone.contexts['data-xszxb-n9'] = Ogone.contexts['data-xszxb-n6'];
Ogone.contexts['data-xszxb-t21'] = Ogone.contexts['data-xszxb-n9'];
Ogone.contexts['data-xszxb-nd7'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    const menu = this.menu;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-main.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen, menu };
};
Ogone.contexts['data-xszxb-n2'] = Ogone.contexts['data-xszxb-nt'];
Ogone.contexts['data-xszxb-t3'] = Ogone.contexts['data-xszxb-nt'];
Ogone.contexts['data-vsrva-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/404.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return {};
};
Ogone.contexts['data-vsrva-n2'] = Ogone.contexts['data-vsrva-nt'];
Ogone.contexts['data-vsrva-n6'] = Ogone.contexts['data-vsrva-n2'];
Ogone.contexts['data-vsrva-t13'] = Ogone.contexts['data-vsrva-n6'];
Ogone.contexts['data-vsrva-n3'] = Ogone.contexts['data-vsrva-n2'];
Ogone.contexts['data-vsrva-n4'] = Ogone.contexts['data-vsrva-n3'];
Ogone.contexts['data-nbbxb-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/routers/.router.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return {};
};
Ogone.contexts['data-nbbxb-t3'] = Ogone.contexts['data-nbbxb-nt'];
Ogone.contexts['data-ybryo-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const item = this.item;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { item };
};
Ogone.contexts['data-ybryo-nd2'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const item = this.item;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { item };
};
Ogone.contexts['data-ybryo-nd7'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const item = this.item;
    if (GET_LENGTH && !(item.status === 'in-progress')) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { item };
};
Ogone.contexts['data-ybryo-nd5'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const item = this.item;
    if (GET_LENGTH && !(item.status === 'todo')) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { item };
};
Ogone.contexts['data-ybryo-nd3'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const item = this.item;
    if (GET_LENGTH && !(item.status === 'ok')) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { item };
};
Ogone.contexts['data-ybryo-t6'] = Ogone.contexts['data-ybryo-nd2'];
Ogone.contexts['data-ybryo-t3'] = Ogone.contexts['data-ybryo-nt'];
Ogone.contexts['data-yz5y5-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/stores/menu.store.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen };
};
Ogone.contexts['data-5vn3y-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/burger.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen };
};
Ogone.contexts['data-5vn3y-nd5'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/burger.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen };
};
Ogone.contexts['data-5vn3y-n10'] = Ogone.contexts['data-5vn3y-nd5'];
Ogone.contexts['data-5vn3y-n8'] = Ogone.contexts['data-5vn3y-nd5'];
Ogone.contexts['data-5vn3y-n6'] = Ogone.contexts['data-5vn3y-nd5'];
Ogone.contexts['data-5vn3y-n2'] = Ogone.contexts['data-5vn3y-nt'];
Ogone.contexts['data-5vn3y-t3'] = Ogone.contexts['data-5vn3y-nt'];
Ogone.contexts['data-yxynr-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const menu = this.menu;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-content.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { menu };
};
Ogone.contexts['data-yxynr-n3'] = Ogone.contexts['data-yxynr-nt'];
Ogone.contexts['data-yxynr-n5'] = Ogone.contexts['data-yxynr-n3'];
Ogone.contexts['data-yxynr-n6'] = Ogone.contexts['data-yxynr-n5'];
Ogone.contexts['data-yxynr-nd4'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const menu = this.menu;
    const _____a_ = menu || [];
    let i0 = POSITION[2], t = (_____a_)[i0];
    if (GET_LENGTH) {
        return (_____a_).length;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-content.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { i0, t, menu };
};
Ogone.contexts['data-yxynr-t3'] = Ogone.contexts['data-yxynr-nt'];
Ogone.contexts['data-nnb5y-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/asyncs/logo.async.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return {};
};
Ogone.contexts['data-nnb5y-n2'] = Ogone.contexts['data-nnb5y-nt'];
Ogone.contexts['data-nnb5y-n3'] = Ogone.contexts['data-nnb5y-n2'];
Ogone.contexts['data-nnb5y-n4'] = Ogone.contexts['data-nnb5y-n3'];
Ogone.contexts['data-xro3n-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const test = this.test;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/left-menu.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { test };
};
Ogone.contexts['data-xro3n-n2'] = Ogone.contexts['data-xro3n-nt'];
Ogone.contexts['data-xro3n-t6'] = Ogone.contexts['data-xro3n-n2'];
Ogone.contexts['data-xro3n-t3'] = Ogone.contexts['data-xro3n-nt'];
Ogone.contexts['data-ssxos-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const title = this.title;
    const text = this.text;
    const code = this.code;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/content.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { title, text, code };
};
Ogone.contexts['data-ssxos-n2'] = Ogone.contexts['data-ssxos-nt'];
Ogone.contexts['data-ssxos-n9'] = Ogone.contexts['data-ssxos-n2'];
Ogone.contexts['data-ssxos-n10'] = Ogone.contexts['data-ssxos-n9'];
Ogone.contexts['data-ssxos-n11'] = Ogone.contexts['data-ssxos-n10'];
Ogone.contexts['data-ssxos-t26'] = Ogone.contexts['data-ssxos-n11'];
Ogone.contexts['data-ssxos-n3'] = Ogone.contexts['data-ssxos-n2'];
Ogone.contexts['data-ssxos-n6'] = Ogone.contexts['data-ssxos-n3'];
Ogone.contexts['data-ssxos-t15'] = Ogone.contexts['data-ssxos-n6'];
Ogone.contexts['data-ssxos-n4'] = Ogone.contexts['data-ssxos-n3'];
Ogone.contexts['data-ssxos-t10'] = Ogone.contexts['data-ssxos-n4'];
Ogone.contexts['data-ssxos-t3'] = Ogone.contexts['data-ssxos-nt'];
Ogone.contexts['data-5xo35-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const articles = this.articles;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/pages/body.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { articles };
};
Ogone.contexts['data-5xo35-n3'] = Ogone.contexts['data-5xo35-nt'];
Ogone.contexts['data-5xo35-nd4'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const articles = this.articles;
    const _____a_ = articles || [];
    let i0 = POSITION[2], article = (_____a_)[i0];
    if (GET_LENGTH) {
        return (_____a_).length;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/pages/body.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { i0, article, articles };
};
Ogone.contexts['data-5xo35-t3'] = Ogone.contexts['data-5xo35-nt'];
Ogone.contexts['data-snroz-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const scrollY = this.scrollY;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/index.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { scrollY };
};
Ogone.contexts['data-snroz-nd13'] = Ogone.contexts['data-snroz-nt'];
Ogone.contexts['data-snroz-n12'] = Ogone.contexts['data-snroz-nt'];
Ogone.contexts['data-snroz-n11'] = Ogone.contexts['data-snroz-nt'];
Ogone.contexts['data-snroz-n4'] = Ogone.contexts['data-snroz-nt'];
Ogone.contexts['data-snroz-n9'] = Ogone.contexts['data-snroz-n4'];
Ogone.contexts['data-snroz-n5'] = Ogone.contexts['data-snroz-n4'];
Ogone.contexts['data-snroz-nd6'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const scrollY = this.scrollY;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/index.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { scrollY };
};
Ogone.contexts['data-snroz-t3'] = Ogone.contexts['data-snroz-nt'];
Ogone.classes['data-xysby-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-xysby']();
        component.requirements = (null);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-xysby-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-ssvvo-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-ssvvo']();
        component.requirements = (null);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-ssvvo-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-o5brr-nd15'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item", "openTree"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd15' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-o5brr-nd15';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-o5brr-nd15'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-o5brr-nd12'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["openTree", "item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd12' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-o5brr-nd12';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-o5brr-nd12'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-o5brr-nd10'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["openTree", "item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd10' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-o5brr-nd10';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-o5brr-nd10'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-o5brr-nd8'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd8' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-o5brr-nd8';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-o5brr-nd8'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-o5brr-nd5'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd5' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-o5brr-nd5';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-o5brr-nd5'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-o5brr-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-o5brr']();
        component.requirements = ([["item", ["Object"]]]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-o5brr-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-xszxb-nd17'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["isOpen"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd17' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-xszxb-nd17';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-xszxb-nd17'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-xszxb-nd5'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["isOpen"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd5' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-xszxb-nd5';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-xszxb-nd5'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-xszxb-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-xszxb']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-xszxb-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-vsrva-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-vsrva']();
        component.requirements = (null);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-vsrva-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-nbbxb-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-nbbxb']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'router';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            routes: [{ "path": "/doc", "name": "documentation", "component": "data-5xo35-nt", "title": "Ogone - documentation" }, { "path": "/todos/:id", "component": "data-vsrva-nt", "name": "todo" }, { "path": 404, "name": 404, "component": "data-vsrva-nt", "title": "404 route not found" }],
            // set the location
            locationPath: location.pathname,
            // set the actualTemplate of the router
            actualTemplate: null,
            // save the route
            actualRoute: null,
            actualRouteName: null,
            // whenever the route change
            routeChanged: true,
            // set state to pass it through the history.state
            historyState: { ...(() => {
                    const url = new URL(location.href);
                    const query = new Map(url.searchParams.entries());
                    return { query };
                })(), },
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle() { }
    // use bindClass method
    // this method allow --class flag
    bindClass() { }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() {
        const o = this.ogone, oc = o.component;
        const rr = Ogone.router.react;
        oc.runtime(0, o.historyState);
        rr.push((path) => {
            o.locationPath = path;
            this.setActualRouterTemplate();
            this.renderRouter();
            return oc.activated;
        });
    }
    routerSearch(route, locationPath) {
        if (typeof locationPath !== 'string')
            return false;
        const { path } = route;
        const splitted = path.toString().split('/');
        const locationSplit = locationPath.split('/');
        const result = {};
        if (!splitted.filter(r => r.trim().length).length !== !locationSplit.filter(r => r.trim().length).length)
            return;
        if (splitted.length !== locationSplit.length)
            return false;
        const error = splitted.find((p, i, arr) => {
            if (!p.startsWith(':')) {
                return locationSplit[i] !== p;
            }
        });
        if (error)
            return false;
        splitted.forEach((p, i, arr) => {
            if (p.startsWith(':')) {
                const param = p.slice(1, p.length);
                arr[i] = null;
                result[param] = locationSplit[i];
            }
        });
        route.params = result;
        return true;
    }
    setActualRouterTemplate() {
        const o = this.ogone, oc = o.component;
        oc.routes = o.routes;
        oc.locationPath = o.locationPath;
        const l = oc.locationPath;
        let rendered = oc.routes.find((r) => r.path === l || this.routerSearch(r, l) || r.path === 404);
        let preservedParams = rendered.params;
        // redirections
        while (rendered && rendered.redirect) {
            rendered = oc.routes.find((r) => r.name === rendered.redirect);
            if (rendered) {
                rendered.params = preservedParams;
            }
        }
        if (!rendered) {
            o.actualTemplate = [new Comment()];
            o.actualRoute = null;
            o.routeChanged = true;
        }
        else if (rendered && !(rendered.once || o.actualRoute === rendered.component)) {
            const { component: uuidC } = rendered;
            const co = document.createElement('template', { is: uuidC });
            o.actualTemplate = [co];
            o.actualRoute = rendered.component;
            o.actualRouteName = rendered.name || null;
            o.routeChanged = true;
            // don't spread o
            // some props of o can overwritte the template.ogone and create errors in context
            // like undefined data
            co.setOgone({
                params: rendered.params || null,
                props: o.props,
                parentComponent: o.parentComponent,
                parentCTXId: o.parentCTXId,
                positionInParentComponent: o.positionInParentComponent
                    .slice(),
                levelInParentComponent: o.levelInParentComponent,
                index: o.index,
                level: o.level,
                position: o.position,
                flags: o.flags,
            });
            // if the route provide any title
            // we change the title of the document
            if (rendered.title) {
                document.title = rendered.title;
            }
        }
        else {
            o.routeChanged = false;
        }
    }
    renderRouter() {
        const o = this.ogone, oc = o.component;
        // update Props before replacement of the element
        oc.updateProps();
        // we will use o.replacer cause it's used in the flag if
        if (!o.actualTemplate) {
            o.actualTemplate = o.replacer;
        }
        if (this.parentNode) {
            this.replaceWith(...o.actualTemplate);
            o.replacer = o.actualTemplate;
        }
        else if (o.routeChanged) {
            const replacer = o.replacer && o.replacer[0].ogone ?
                [[o.replacer[0].context.placeholder], o.replacer[0].ogone.nodes].find(n => n[0] && n[0].isConnected)
                : o.replacer;
            if (!replacer)
                return;
            replacer.slice(1, replacer.length).forEach(n => n.remove());
            for (let n of replacer) {
                n.isConnected ? n.replaceWith(...o.actualTemplate) : '';
            }
            o.replacer[0] && o.replacer[0].isComponent ? o.replacer[0].destroy() : 0;
        }
        o.replacer = o.actualTemplate;
        oc.runtime(o.actualRouteName || o.locationPath, history.state);
    }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-nbbxb-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        this.setActualRouterTemplate();
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.renderRouter();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
        this.triggerLoad();
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-ybryo-nd7'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd7' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-ybryo-nd7';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-ybryo-nd7'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-ybryo-nd5'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd5' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-ybryo-nd5';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-ybryo-nd5'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-ybryo-nd3'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd3' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-ybryo-nd3';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-ybryo-nd3'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-ybryo-nd2'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd2' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-ybryo-nd2';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-ybryo-nd2'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-ybryo-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-ybryo']();
        component.requirements = ([["item", ["Object"]]]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-ybryo-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-yz5y5-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-yz5y5']();
        component.requirements = (null);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'store';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle() { }
    // use bindClass method
    // this method allow --class flag
    bindClass() { }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() {
        const o = this.ogone;
        const oc = o.component;
        if (oc.namespace !== 'menu') {
            const error = 'the attribute namespace is not the same provided in the component store';
            const BadNamspaceException = new Error(`[Ogone] ${error}`);
            Ogone.error(error, 'Store Module: Bad Namsepace Exception', {
                message: `
            store namespace: menu
            attribute namespace: ${oc.namespace}
            `
            });
            throw BadNamspaceException;
        }
        oc.startLifecycle();
        this.removeNodes().remove();
    }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-yz5y5-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
        oc.namespace = this.getAttribute('namespace') || null;
        oc.parent.store[oc.namespace] = oc;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.renderStore();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-5vn3y-nd5'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = null;
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd5' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-5vn3y-nd5';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        o.getContext = Ogone.contexts['data-5vn3y-nd5'].bind(o.component.data);
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-5vn3y-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-5vn3y']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-5vn3y-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-yxynr-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-yxynr']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-yxynr-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-nnb5y-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-nnb5y']();
        component.requirements = (null);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-nnb5y-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-xro3n-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-xro3n']();
        component.requirements = ([["test", ["Number"]]]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-xro3n-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-ssxos-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-ssxos']();
        component.requirements = ([["title", ["String"]], ["text", ["String"]], ["code", ["String"]]]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-ssxos-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-5xo35-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-5xo35']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-5xo35-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-snroz-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-snroz']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-snroz-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
customElements.define('data-snroz-nt', Ogone.classes['data-snroz-nt'], { extends: 'template' });
customElements.define('data-5xo35-nt', Ogone.classes['data-5xo35-nt'], { extends: 'template' });
customElements.define('data-ssxos-nt', Ogone.classes['data-ssxos-nt'], { extends: 'template' });
customElements.define('data-xro3n-nt', Ogone.classes['data-xro3n-nt'], { extends: 'template' });
customElements.define('data-nnb5y-nt', Ogone.classes['data-nnb5y-nt'], { extends: 'template' });
customElements.define('data-yxynr-nt', Ogone.classes['data-yxynr-nt'], { extends: 'template' });
customElements.define('data-5vn3y-nt', Ogone.classes['data-5vn3y-nt'], { extends: 'template' });
customElements.define('data-5vn3y-nd5', Ogone.classes['data-5vn3y-nd5']);
customElements.define('data-yz5y5-nt', Ogone.classes['data-yz5y5-nt'], { extends: 'template' });
customElements.define('data-ybryo-nt', Ogone.classes['data-ybryo-nt'], { extends: 'template' });
customElements.define('data-ybryo-nd2', Ogone.classes['data-ybryo-nd2']);
customElements.define('data-ybryo-nd3', Ogone.classes['data-ybryo-nd3']);
customElements.define('data-ybryo-nd5', Ogone.classes['data-ybryo-nd5']);
customElements.define('data-ybryo-nd7', Ogone.classes['data-ybryo-nd7']);
customElements.define('data-nbbxb-nt', Ogone.classes['data-nbbxb-nt'], { extends: 'template' });
customElements.define('data-vsrva-nt', Ogone.classes['data-vsrva-nt'], { extends: 'template' });
customElements.define('data-xszxb-nt', Ogone.classes['data-xszxb-nt'], { extends: 'template' });
customElements.define('data-xszxb-nd5', Ogone.classes['data-xszxb-nd5']);
customElements.define('data-xszxb-nd17', Ogone.classes['data-xszxb-nd17']);
customElements.define('data-o5brr-nt', Ogone.classes['data-o5brr-nt'], { extends: 'template' });
customElements.define('data-o5brr-nd5', Ogone.classes['data-o5brr-nd5']);
customElements.define('data-o5brr-nd8', Ogone.classes['data-o5brr-nd8']);
customElements.define('data-o5brr-nd10', Ogone.classes['data-o5brr-nd10']);
customElements.define('data-o5brr-nd12', Ogone.classes['data-o5brr-nd12']);
customElements.define('data-o5brr-nd15', Ogone.classes['data-o5brr-nd15']);
customElements.define('data-ssvvo-nt', Ogone.classes['data-ssvvo-nt'], { extends: 'template' });
customElements.define('data-xysby-nt', Ogone.classes['data-xysby-nt'], { extends: 'template' });
          </script>
  </head>
  <body>
      <template is="data-snroz-nt"></template>
  </body>
</html>
