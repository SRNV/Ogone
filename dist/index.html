
<html>
  <head>
      
          <style>
  h1[data-555ax], h2[data-555ax], h3[data-555ax], h4[data-555ax] {
    color: #193b48;
  }
  .logo[data-555ax] {
    flex: 2;
    display: inline-flex;
    flex-direction: row;
    max-width: 124px;
    min-width: 124px;
    min-height: 65px;
  }
  .header[data-555ax] {
    background: var(--o-header);
    padding: 10px;
    filter: drop-shadow(0px 10px 0px #00000087);
    display: flex;
    position: sticky;
    top: 0px;
    transition: top 0.5s ease;
    overflow: hidden;
    z-index: 500;
  }
  .title[data-555ax] {
    margin: auto;
    letter-spacing: 3px;
  }


  .container[data-xxnzv] {
    height: auto;
    width: auto;
    background: black;
    animation-name: fade-in-right;
    animation-iteration-count: 1;
    animation-duration: 0.5s;
  }


  .container[data-5b3rz] {
    min-height: 400px;
    width: 100%;
    display: flex;
  }
  @media screen and (max-width: 965px) {
    .container[data-5b3rz] {
      flex-direction: column;
    }
  }
  .left[data-5b3rz] {
    background: var(--o-background);
    flex: 6;
    padding: 98px;
    padding-left: 77px;
  }
  .right[data-5b3rz] {
    background: var(--o-black);
    flex: 5;
    padding: 53px;
    padding-top: 135px;
    padding-bottom: 135px;
  }
  .code[data-5b3rz] {
    white-space: pre;
  }
  .text[data-5b3rz] {
    color: var(--o-grey);
    margin-left: 30px;
  }
  .title[data-5b3rz] {
    color: var(--o-dark-blue);
  }


  .container[data-oyzy5] {
    position: fixed;
    top: 35%;
    width: 40px;
    height: 300px;
    right: 0;
    background: #2f3035;
    border-radius: 5px 0 0 5px;
    filter: drop-shadow(0px 2px 4px #00000086);
  }


  .img[data-3vbxo] {
    width: auto;
  }
  .logo-back[data-3vbxo] {
    background: var(--o-primary);
    padding: 6px;
    border-radius: 100%;
    animation-name: fade-in-down;
    animation-iteration-count: 1;
    animation-duration: 1s;
  }
  .container[data-3vbxo] {
    width: 60px;
    height: auto;
  }


  .menu[data-5zxav] {
    flex: 8;
    display: flex;
    flex-direction: row;
    vertical-align: middle;
    align-items: center;
    justify-content: flex-end;
  }


.line[data-yoanx], .container[data-yoanx] {
  border-radius: 5px;
  transition: filter 0.2s ease;
  cursor: pointer;
}
.container[data-yoanx] {
    padding: 9px;
    width: 28px;
    height: auto;
    background: var(--o-header);
    display: flex;
    flex-direction: column;
    filter: drop-shadow(0px 0px 0px #00000045);
}
.container[data-yoanx]:hover[data-yoanx] {
    filter: drop-shadow(0px 5px 3px #00000045);
}
.line[data-yoanx] {
  background: #848181;
  margin-top: 2px;
  margin-bottom: 2px;
  height: 4px;
}
.container[data-yoanx]:hover[data-yoanx] .line[data-yoanx] {
    background: var(--o-primary);
}



.container[data-x33ao] {
  display: inline-flex;
  background: var(--o-header);
  height: 100%;
  vertical-align: middle;
  align-items: center;
  padding: 23px;
  text-transform: capitalize;
  color: #afafaf;
  cursor: pointer;
  user-select: none;
}
.container[data-x33ao]:hover[data-x33ao] {
  background: var(--o-primary);
  color: var(--o-background);
}
.ok[data-x33ao], .in-progress[data-x33ao], .todo[data-x33ao] {
  height: 3px;
  width: 3px;
  padding: 3px;
  border-radius: 20px;
  margin: 5px;
}
.ok[data-x33ao] {
  background: var(--o-success)
}
.todo[data-x33ao] {
  background: var(--o-error)
}
.in-progress[data-x33ao] {
  background: var(--o-info)
}



.container[data-o3sab] {
  display: flex;
  justify-content: center;
  margin: auto;
  flex-direction: column;
}
.logo[data-o3sab] {
  width: 400px;
  height: auto;
  animation-name: rotate;
  animation-duration: 5s;
  animation-timing-function: ease;
  animation-iteration-count: infinite;
  animation-direction: alternate;
}
.text[data-o3sab] {
  font-weight: 400;
  font-size: 24pt;
  text-align: center;
  color: #9e9e9e;
  margin: 40px;
}
.logo-back[data-o3sab] {
  filter: drop-shadow(2px 4px 6px var(--o-primary));
  background: var(--o-primary);
  border-radius: 100%;
  padding: 56px;
  animation-name: popup;
  animation-duration: 0.5s;
  animation-timing-function: cubic-bezier(0.1, -0.6, 0.2, 0);
  max-width: 500px;
  margin: auto;
}


  .left-menu[data-s3sox] {
    height: 100vh;
    width: 300px;
    min-width: 300px;
    max-width: 300px;
    position: fixed;
    top: 0px;
    transition: left 0.5s ease;
    left: 0px;
    background: var(--o-header);
    z-index: 2000;
    display: flex;
    filter: drop-shadow(0px 0px 10px #000000);
    flex-direction: column;
  }
  .close[data-s3sox] {
    left: -100%;
  }
  .darken[data-s3sox] {
    background: #00000090;
    width: 100vw;
    height: 100vh;
    top: 0px;
    left: 0px;
    position: fixed;
    z-index: 1999;
  }
  .header[data-s3sox] {
    padding: 10px;
    display: flex;
    vertical-align: middle;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #4e4e4e;
  }
  .tree[data-s3sox] {
    overflow-x: hidden;
    overflow-y: auto;
  }


.container[data-avsnr] {
  color: var(--o-grey);
  display: flex;
  flex-direction: column;
  flex: 1;
}
.child[data-avsnr] {
  padding-left: 30px;
  height: 0;
  overflow: hidden;
  transition: flex 0.5s ease;
  background: #00000034;
}
.child-open[data-avsnr] {
  flex: 1;
}
.title[data-avsnr] {
  padding-bottom: 10px;
  border-bottom: 1px solid #555;
  padding: 5px;
  cursor: pointer;
  flex: 1;
  display: flex;
  justify-content: space-between;
}
.title[data-avsnr]:hover[data-avsnr] {
  background: var(--o-primary);
  color: white;
}
.child[data-avsnr] .title[data-avsnr] {
  border-left: 1px solid #555;
}
.status[data-avsnr] {
  display: list-item;
}
.ok[data-avsnr] {
  color: var(--o-success)
}
.todo[data-avsnr] {
  color: var(--o-error)
}
.in-progress[data-avsnr] {
  color: var(--o-info)
}


.container[data-xsano] {
  overflow: hidden;
  display: flex;
  flex-direction: row-reverse;
}
.scrollbar[data-xsano] {
  width: 9px;
  flex: 1;
  background: #3e3e3e;
}
.scrollbar-button[data-xsano] {
  height: 20px;
  width: 100%;
  background: var(--o-grey);
}
.content[data-xsano] {
  flex: 18;
}
.view[data-xsano] {
  flex: 18;
  overflow: auto;
}


  .img[data-zbnay] {
    width: auto;
  }
  .logo-back[data-zbnay] {
    background: var(--o-primary);
    padding: 6px;
    border-radius: 100%;
  }
  .container[data-zbnay] {
    width: 60px;
    height: auto;
  }
</style>
          
  <link href="/public/style.css" rel="stylesheet"/>
  <link href="/public/animations.css" rel="stylesheet"/>
  <link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.2/styles/night-owl.min.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto|Varela+Round" rel="stylesheet"></link>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.9.1/showdown.min.js"></script>
  
          <script>
            function OComponent() {
    this.key = null;
    this.data = null;
    this.dependencies = null;
    this.state = 0;
    this.activated = true;
    this.namespace = null;
    this.store = {};
    this.contexts = {
        for: {},
    };
    // for async context
    this.promises = [];
    this.resolve = null;
    this.async = {
        then: null,
        catch: null,
        finally: null,
    };
    this.dispatchAwait = null;
    this.promiseResolved = false;
    // events describers
    // this.events = {};
    // all nodes that's are dynamics will save a function into this property
    // like if we have
    //  <node --for="array as (el, i)" />
    // this node will register a function() { ... } that will be triggered each time there is an update
    //this.rerenderAsync = null;
    this.react = [];
    this.texts = [];
    this.childs = [];
    this.startLifecycle = (params, event) => {
        if (!this.activated)
            return;
        if (this.type === "store") {
            this.initStore();
        }
        // WIP
        Object.seal(this.data);
        this.runtime(0, params, event);
        this.state = 1; // component is rendered
    };
    this.update = (dependency) => {
        if (!this.activated)
            return;
        if (this.type === "store") {
            this.updateStore(dependency);
            return;
        }
        this.runtime(`update:${dependency}`);
        this.reactTo(dependency);
        this.renderTexts(dependency);
        this.childs.filter((c) => c.type !== "store").forEach((c) => {
            c.updateProps(dependency);
        });
    };
    this.renderTexts = (dependency) => {
        if (!this.activated)
            return;
        this.texts.forEach((t, i, arr) => {
            // if there is no update of the texts
            // this can be the reason why
            if (t && !t(dependency))
                delete arr[i];
        });
    };
    this.reactTo = (dependency) => {
        if (!this.activated)
            return;
        this.react.forEach((t, i, arr) => {
            if (t && !t(dependency))
                delete arr[i];
        });
    };
    this.initStore = () => {
        if (!Ogone.stores[this.namespace]) {
            Ogone.stores[this.namespace] = {
                ...this.data,
            };
        }
        // save the component's reaction into Ogone.clients with the key of the component
        // and a function
        Ogone.clients.push([this.key, (namespace, key, overwrite) => {
                if (namespace === this.namespace
                    && this.data
                    && this.parent
                    && this.parent.data
                    && key in this.parent.data) {
                    if (!overwrite) {
                        this.data[key] = Ogone.stores[this.namespace][key];
                    }
                    else {
                        Ogone.stores[this.namespace][key] = this.data[key];
                    }
                    this.parent.data[key] = this.data[key];
                    this.parent.update(key);
                }
                return true;
            }]);
    };
    this.updateStore = (dependency) => {
        // find the reaction of this store module with the key
        // @ts-ignore
        const [key, client] = Ogone.clients.find(([key]) => key === this.key);
        if (client) {
            // use the namespace, the dependency or property that should change
            // @ts-ignore
            client(this.namespace, dependency, true);
            // update other modules
            Ogone.clients.filter(([key]) => key !== this.key).forEach(([key, f], i, arr) => {
                if (f && !f(this.namespace, dependency, false)) {
                    delete arr[i];
                }
            });
        }
    };
    this.updateProps = (dependency) => {
        if (!this.activated)
            return;
        if (this.type === "store")
            return;
        if (!this.requirements || !this.props)
            return;
        this.requirements.forEach(([key, constructors]) => {
            const prop = this.props.find((prop) => prop[0] === key);
            const isAny = constructors.includes(null);
            if (!prop && !isAny) {
                const UndefinedPropertyForComponentException = `${key} is required as property but still undefined. Please use this syntax\n\t\t<component :${key}="..."></component>`;
                const err = new Error("[Ogone]  " + UndefinedPropertyForComponentException);
                Ogone.error(UndefinedPropertyForComponentException, `Undefined property ${key}. But ${key} is required in component`, err);
                throw err;
            }
            if (!prop)
                return;
            const value = this.parentContext({
                getText: `${prop[1]}`,
                position: this.positionInParentComponent,
            });
            if ((value === undefined || value === null) && !isAny) {
                const message = `${key} is required as property but can\'t be null. Please use this syntax\n\t\t<component :${key}="${constructors.join(" | ")}"></component>`;
                const NullishPropertyException = new Error("[Ogone]  " + message);
                Ogone.error(message, `Property ${key} can't be null for the component`, NullishPropertyException);
                throw NullishPropertyException;
            }
            if (!constructors.includes(value.constructor.name)) {
                const message = `${key} is required as property but it's value is not one of ${constructors.join(" | ")}
            evaluated value: ${prop[1]}
            constructor: ${value.constructor.name}`;
                const PropertyDontMatchWithConstructorsException = new Error("[Ogone] " + message);
                Ogone.error(message, `TypeError for property ${key}`, PropertyDontMatchWithConstructorsException);
                throw PropertyDontMatchWithConstructorsException;
            }
            if (this.data && value !== this.data[key]) {
                this.data[key] = value;
                this.update(key);
                if (this.type === "async") {
                    if (!this.dependencies)
                        return;
                    if (dependency &&
                        this.dependencies.find((d) => d.indexOf(dependency) > -1)) {
                        // let the user rerender
                        this.runtime("async:update", {
                            updatedParentProp: dependency,
                        });
                    }
                }
            }
        });
    };
    this.render = (Onode, /** original node */ opts) => {
        if (!Onode || !opts)
            return;
        // Onode is a web component
        // based on the user token
        // this web component is a custom Element
        // not an extension of an element cause the attr "is" is not dynamic
        // at the first call of this function Onode is not "rendered" (replaced by the required element)
        let { callingNewComponent, length: dataLength } = opts;
        typeof dataLength === "object" ? dataLength = 1 : [];
        const context = Onode.context;
        // no need to render if it's the same
        if (context.list.length === dataLength)
            return;
        let previousTemplate;
        // first we add missing nodes, we use cloneNode to generate the web-component
        for (let i = context.list.length, a = dataLength; i < a; i++) {
            let node;
            // @ts-ignore
            node = document.createElement(context.name, { is: Onode.extends });
            node.setOgone({
                index: i,
                originalNode: false,
                level: Onode.ogone.level,
                position: Onode.ogone.position.slice(),
                flags: Onode.ogone.flags,
                orinal: Onode,
                ...(!callingNewComponent ? { component: this } : {
                    props: Onode.ogone.props,
                    params: Onode.ogone.params,
                    parentComponent: Onode.ogone.parentComponent,
                    parentCTXId: Onode.ogone.parentCTXId,
                    positionInParentComponent: Onode.ogone.positionInParentComponent
                        .slice(),
                    levelInParentComponent: Onode.ogone.levelInParentComponent,
                }),
            });
            if (i === 0) {
                context.placeholder.replaceWith(node);
            }
            else {
                let lastEl = context.list[i - 1];
                if (lastEl && lastEl.isConnected) {
                    lastEl.insertElement("afterend", node);
                }
                else if (Onode && Onode.parentNode) {
                    Onode.parentNode.insertBefore(node, Onode.nextElementSibling);
                }
            }
            context.list.push(node);
            previousTemplate = node;
        }
        // no need to remove if it's the same
        if (context.list.length === dataLength)
            return;
        // now we remove the extra elements
        for (let i = context.list.length, a = dataLength; i > a; i--) {
            if (context.list.length === 1) {
                // get the first element of the webcomponent
                let firstEl = context.list[0];
                if (firstEl && firstEl.firstNode && firstEl.isConnected) {
                    firstEl.insertElement('beforebegin', context.placeholder);
                }
                else if (Onode.parentNode) {
                    const { parentNode } = context;
                    parentNode.insertBefore(context.placeholder, Onode);
                }
            }
            const rm = context.list.pop();
            // deactivate all the reactions of the component
            rm.removeNodes().remove();
        }
    };
    return this;
}
// @ts-ignore
const Ogone = {
    // store
    stores: {},
    clients: [],
    render: {},
    contexts: {},
    components: {},
    classes: {},
    errorPanel: null,
    warnPanel: null,
    successPanel: null,
    infosPanel: null,
    historyError: null,
    errors: 0,
    firstErrorPerf: null,
    sound: null,
    oscillator: null,
    error(message, errorType, errorObject) {
        // here we render the errors in development
        if (!this.errorPanel) {
            const p = document.createElement("div");
            const h = document.createElement("div");
            Object.entries({
                zIndex: "5000000",
                background: "#00000097",
                width: "100vw",
                height: "100vh",
                position: "fixed",
                overflowY: "auto",
                justifyContent: "center",
                display: "grid",
                flexDirection: "column",
            }).forEach(([key, value]) => p.style[key] = value);
            h.style.width = "100vw";
            h.style.position = "fixed";
            h.style.background = "black";
            h.style.bottom = "26px";
            h.style.height = "20px";
            h.style.left = "0px";
            h.style.zIndex = "50000000";
            this.errorPanel = p;
            this.errorPanel.append(h);
            this.historyError = h;
        }
        this.errors++;
        const err = document.createElement("div");
        Object.entries({
            zIndex: "5000000",
            background: "#000000",
            minHeight: "fit-content",
            maxWidth: "70%",
            padding: "21px",
            color: "red",
            borderLeft: "3px solid red",
            margin: "auto",
            display: "inline-flex",
            flexDirection: "column",
        }).forEach(([key, value]) => err.style[key] = value);
        const errorId = this.errors;
        const code = document.createElement("code");
        const stack = document.createElement("code");
        const h = document.createElement("h4");
        const errorPin = document.createElement("div");
        // set the text
        h.innerText = `[Ogone] Error ${errorId}: ${errorType || "Undefined Type"}`;
        code.innerText = `${message.trim()}`;
        stack.innerText = `${
        // @ts-ignore
        errorObject && errorObject.stack
            // @ts-ignore
            ? errorObject.stack.replace(message, "")
            : ""}`;
        // check if stack is empty or not
        if (!stack.innerText.length && errorObject && errorObject.message) {
            stack.innerText = `${errorObject && errorObject.message ? errorObject.message : ""}`;
        }
        !stack.innerText.length ? stack.innerText = "undefined stack" : "";
        // set the styles
        code.style.marginLeft = "20px";
        code.style.whiteSpace = "pre-wrap";
        code.style.wordBreak = "break-word";
        stack.style.marginLeft = "20px";
        stack.style.color = "#dc7373";
        stack.style.padding = "17px";
        stack.style.background = "#462626";
        stack.style.whiteSpace = "pre-wrap";
        stack.style.wordBreak = "break-word";
        stack.style.border = "1px solid";
        stack.style.marginTop = "10px";
        h.style.color = "#8c8c8c";
        errorPin.style.background = "red";
        errorPin.style.width = "13px";
        errorPin.style.height = errorPin.style.width;
        errorPin.style.position = "fixed";
        errorPin.style.bottom = "30px";
        errorPin.style.zIndex = "50000000";
        const relativePinPosition = Math.round((this.firstErrorPerf / performance.now()) * 30) + 30;
        errorPin.style.left = this.firstErrorPerf
            ? `${relativePinPosition}px`
            : "30px";
        if (!this.firstErrorPerf) {
            this.firstErrorPerf = performance.now();
        }
        this.errorPanel.style.paddingTop = "30px";
        // set the grid of errors
        err.style.gridArea = `e${errorId}`;
        const m = 2;
        let grid = "";
        let i = 0;
        let a = 0;
        for (i = 0, a = this.errorPanel.childNodes.length + 1; i < a; i++) {
            grid += `e${i + 1} `;
        }
        let b = i;
        while (i % m) {
            grid += `e${b} `;
            i++;
        }
        const cells = grid.split(" ");
        var o, j, temparray, chunk = m;
        let newgrid = "";
        for (o = 0, j = cells.length - 1; o < j; o += chunk) {
            temparray = cells.slice(o, o + chunk);
            newgrid += ` "${temparray.join(" ")}"`;
        }
        this.errorPanel.style.gridGap = "10px";
        this.errorPanel.style.gridAutoRows = "max-content";
        this.errorPanel.style.gridTemplateAreas = newgrid;
        err.style.animationName = "popup";
        err.style.animationIterationCoutn = "1";
        err.style.animationDuration = "0.5s";
        // append elements
        err.append(h, code, stack);
        this.errorPanel.append(err);
        this.errorPanel.append(errorPin);
        this.errorPanel.style.pointerEvents = "scroll";
        //  append only if it's not in the document
        !this.errorPanel.isConnected ? document.body.append(this.errorPanel) : [];
    },
};
Ogone.router = {
    react: [],
    actualRoute: null,
    go: (url, state) => {
        if (!Ogone.router)
            return;
        if (Ogone.router.actualRoute === url)
            return;
        // protect from infinite loop
        Ogone.router.actualRoute = url;
        Ogone.router.react.forEach((r, i, arr) => {
            if (r && !r(url, state))
                delete arr[i];
        });
        // @ts-ignore
        history.pushState(state || {}, "", url || "/");
    },
};
// @ts-ignore
window.onpopstate = function (event) {
    // @ts-ignore
    Ogone.router.go(location.pathname, event.state);
};
// @ts-ignore
const contexteAudio = new (window.AudioContext || window.webkitAudioContext)();
// create Oscillator node
Ogone.sound = (opts) => {
    if (Ogone.oscillator)
        return;
    const oscillator = contexteAudio.createOscillator();
    const gainNode = contexteAudio.createGain();
    // for the volume
    oscillator.connect(gainNode);
    gainNode.connect(contexteAudio.destination);
    if (!opts)
        return;
    if (!(opts instanceof Object))
        return;
    const { hz = 440, type = 'sine', duration = 20, volume = 0.03, time = 200 } = opts;
    oscillator.type = type;
    gainNode.gain.value = volume;
    oscillator.frequency.value = hz;
    Ogone.oscillator = oscillator;
    setTimeout(() => {
        Ogone.oscillator.start();
        setTimeout(() => {
            Ogone.oscillator.stop();
        }, duration);
    }, time);
    oscillator.onended = () => {
        Ogone.oscillator = null;
        if (opts.onended)
            opts.onended();
    };
};
function hmrSound() {
    Ogone.sound({
        duration: 15,
        volume: 0.05,
        hz: 40,
        type: 'square',
        time: 0,
        onended: () => {
            Ogone.sound({
                duration: 30,
                volume: 0.05,
                type: 'sine',
                hz: Math.round(40 * 1.5),
                time: 2,
            });
        },
    });
}
Ogone.mod = {
    "*": [],
};
Ogone.run = {};
Ogone.imp = async function (url) {
    if (Ogone.mod[url])
        return;
    try {
        const mod = await import(url);
        Ogone.mod[url] = mod;
        return mod;
    }
    catch (err) {
        Ogone.error(err.message, "Error in Dynamic Import", {
            message: `
        module's url: ${url}
        `,
        });
    }
};
Ogone.hmr = async function (url) {
    try {
        const mod = await import(`${url}?p=\${performance.now()}`);
        const keys = Object.keys(Ogone.mod);
        keys.filter((key) => key === url).forEach((key) => {
            Ogone.mod[key] = mod;
        });
        Ogone.mod["*"]
            .forEach(([key, f], i, arr) => {
            key === url && f && !f(mod) ? delete arr[i] : 0;
        });
        return mod;
    }
    catch (err) {
        Ogone.error(err.message, "HMR-Error", {
            message: `
        module's url: ${url}
        `,
        });
        throw err;
    }
};
Ogone.hmrTemplate = async function (uuid, pragma) {
    try {
        const templates = Ogone.mod[uuid];
        if (templates) {
            templates.forEach((f, i, arr) => {
                f && !f(pragma) ? delete arr[i] : 0;
            });
        }
        return templates;
    }
    catch (err) {
        Ogone.error(err.message, "HMR-Error", err);
        throw err;
    }
};
Ogone.hmrRuntime = async function (uuid, runtime) {
    try {
        const components = Ogone.run[uuid];
        if (components) {
            components.forEach((c, i, arr) => {
                if (c.activated) {
                    c.runtime = runtime.bind(c.data);
                    c.runtime(0);
                    c.renderTexts(true);
                }
                else {
                    delete arr[i];
                }
            });
        }
        return components;
    }
    catch (err) {
        Ogone.error(err.message, "HMR-Error", err);
        throw err;
    }
};
// @ts-ignore
const ws = new WebSocket(`ws://localhost:7463/`);
ws.onmessage = (msg) => {
    const { url, type, uuid, pragma, ctx, style, runtime } = JSON.parse(msg.data);
    if (type === "javascript") {
        Ogone.hmr(url).then(() => {
            console.warn("[Ogone] hmr:", url);
            hmrSound();
            Ogone.infos({
                message: `[HMR] module updated: ${url}`,
            });
        });
    }
    if (type === "template" && pragma && uuid) {
        eval(ctx);
        Ogone.hmrTemplate(uuid, pragma).then(() => {
            hmrSound();
            Ogone.infos({
                message: `[HMR] template updated: ${uuid}`,
            });
        });
    }
    if (type === "reload") {
        console.warn("[Ogone] hmr: reloading the application");
        hmrSound();
        Ogone.infos({
            message: `[HMR] socket lost. Reloading your application`,
        });
        setTimeout(() => {
            location.reload();
        }, 1000);
    }
    if (type === "style") {
        document.querySelector(`style[id="${uuid}"]`).innerHTML = style;
        hmrSound();
        Ogone.infos({
            message: `[HMR] style updated: ${uuid}`,
        });
    }
    if (type === "runtime") {
        const r = eval(runtime);
        Ogone.hmrRuntime(uuid, (r || function () { })).then(() => {
            hmrSound();
            Ogone.infos({
                message: `[HMR] component updated: ${uuid}`,
            });
        });
    }
};
ws.onclose = () => {
    setTimeout(() => {
        console.warn("[Ogone] ws closed: reloading");
        location.reload();
    }, 1000);
};
Ogone.showPanel = (panelName, time) => {
    const panel = Ogone[panelName + 'Panel'];
    if (panel) {
        document.body.append(panel);
        if (time) {
            setTimeout(() => {
                const f = document.createDocumentFragment();
                f.append(panel);
            }, time);
        }
    }
};
Ogone.infos = (opts) => {
    if (!Ogone.infosPanel) {
        const container = document.createElement('div');
        container.style.position = 'fixed';
        container.style.opacity = '0.85';
        container.style.bottom = '0px';
        container.style.left = '0px';
        container.style.background = 'var(--o-header, #333333)';
        container.style.padding = '5px';
        container.style.paddingRight = '15px';
        container.style.width = 'max-content';
        container.style.color = 'var(--o-grey, #cecece)';
        container.style.fontSize = '10pt';
        container.style.fontFamily = 'sans-serif';
        container.style.borderLeft = '3px solid var(--o-secondary, #61c3aa)';
        container.style.zIndex = '400000';
        const p = document.createElement('p');
        Ogone.infosPanel = container;
        Ogone.infosPanel.p = p;
    }
    const { p } = Ogone.infosPanel;
    p.innerHTML = opts.message;
    Ogone.infosPanel.innerHTML = p.outerHTML;
    Ogone.showPanel('infos', 2000);
};
Ogone.components['data-555ax'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "scrollY": 0 };
    this.refs = {};
    const Refs = this.refs;
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && ![].includes(_state)) {
                return;
            }
            switch (_state) {
                default:
                    const header = document.getElementById('header');
                    window.addEventListener('scroll', (ev) => {
                        if (window.scrollY > this.scrollY) {
                            header.style.top = '-100px';
                        }
                        else {
                            header.style.top = '0px';
                        }
                        this.scrollY = window.scrollY;
                        ____('scrollY', this);
                    });
                    break;
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/index.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-xxnzv'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "articles": [{ "title": "Experimental tool for a fullstack use.", "text": "Ogone is an experimental tool for Fullstack dev. \nFully based on Deno.", "code": " o3.run({\n \tentrypoint: '/app/index.o3',\n \tport: 4000,\n })" }, { "title": "Get Started with the classic greeting app", "text": "TODO", "code": "<p>Hello ${name}</p>\n <proto>\n \tdef:\n \t\tname: Rudy\n </proto>" }, { "title": "Install Ogone", "text": "TODO", "code": "import o3 from \"https://deno.land/x/ogone/mod.ts\"" }, { "title": "Using case, default, def, before-each keywords to rule the component", "text": "TODO", "code": " <proto>\n \tdef:\n \t\tyaml: true\n \tcase 'update:yaml':\n \tdefault:\n \t\tthis.yaml = true;\n \tbreak;\n </proto>" }, { "title": "read def in yml files", "text": "TODO", "code": "<proto def=\"path/to/source.yml\"/>" }, { "title": "Default/Cases execution", "text": "TODO", "code": " <p>${count}</p>\n <button --click:increase>\n \tincrease\n </button>\n <proto>\n \tdef:\n \t\tcount:0\n \tcase 'click:increase':\n \t\tthis.count++;\n \t\tif (this.count > 5) execute default;\n \tbreak;\n \tdefault:\n \t\tthis.count = 0;\n \tbreak;\n </proto>" }] };
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-5b3rz'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "title": null, "text": null, "code": null };
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-oyzy5'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "test": null };
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-3vbxo'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = {};
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-5zxav'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "menu": [{ "name": "Docs", "route": "/doc", "status": "in-progress" }, { "name": "Api", "route": "/api", "status": "todo" }, { "name": "todos", "route": "/todos/testParams", "status": "todo" }, { "name": "project", "route": "/project", "status": "todo" }, { "name": "support", "route": "/support", "status": "todo" }] };
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-yoanx'] = function () {
    OComponent.call(this);
    const Store = {
        dispatch: (id, ctx) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, action] = path;
                const mod = this.store[namespace];
                if (mod && mod.runtime) {
                    return mod.runtime(`action:${action}`, ctx)
                        .catch((err) => Ogone.error(err.message, `Error in dispatch. action: ${action} component: examples/app/components/burger.o3`, err));
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.runtime) {
                    return mod.runtime(`action:${id}`, ctx)
                        .catch((err) => Ogone.error(err.message, `Error in dispatch. action: ${action} component: examples/app/components/burger.o3`, err));
                }
            }
        },
        commit: (id, ctx) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, mutation] = path;
                const mod = this.store[namespace];
                if (mod && mod.runtime) {
                    return mod.runtime(`mutation:${mutation}`, ctx).catch((err) => Ogone.error(err.message, `Error in commit. mutation: ${mutation} component: examples/app/components/burger.o3`, err));
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.runtime) {
                    return mod.runtime(`mutation:${id}`, ctx).catch((err) => Ogone.error(err.message, `Error in commit. mutation: ${id} component: examples/app/components/burger.o3`, err));
                }
            }
        },
        get: (id) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, get] = path;
                const mod = this.store[namespace];
                if (mod && mod.data) {
                    return mod.data[get];
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.data) {
                    return mod.data[id];
                }
            }
        },
    };
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "isOpen": false };
    this.refs = {};
    const Refs = this.refs;
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && !['click:openMenu'].includes(_state)) {
                return;
            }
            switch (_state) {
                case 'click:openMenu':
                    Store.dispatch('menu/toggle');
                    break;
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/components/burger.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-35zxv'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "isOpen": false };
    this.refs = {};
    const Refs = this.refs;
    const __run = (async function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && !['action:toggle'].includes(_state)) {
                return;
            }
            switch (_state) {
                case 'action:toggle':
                    this.isOpen = !this.isOpen;
                    ____('isOpen', this);
                    break;
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/stores/menu.store.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-x33ao'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "item": null };
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-z3yrn'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = {};
    this.refs = {};
    const Refs = this.refs;
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            switch (_state) {
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/routers/.router.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-o3sab'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = {};
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-s3sox'] = function () {
    OComponent.call(this);
    const Store = {
        dispatch: (id, ctx) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, action] = path;
                const mod = this.store[namespace];
                if (mod && mod.runtime) {
                    return mod.runtime(`action:${action}`, ctx)
                        .catch((err) => Ogone.error(err.message, `Error in dispatch. action: ${action} component: examples/app/components/menu/menu-main.o3`, err));
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.runtime) {
                    return mod.runtime(`action:${id}`, ctx)
                        .catch((err) => Ogone.error(err.message, `Error in dispatch. action: ${action} component: examples/app/components/menu/menu-main.o3`, err));
                }
            }
        },
        commit: (id, ctx) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, mutation] = path;
                const mod = this.store[namespace];
                if (mod && mod.runtime) {
                    return mod.runtime(`mutation:${mutation}`, ctx).catch((err) => Ogone.error(err.message, `Error in commit. mutation: ${mutation} component: examples/app/components/menu/menu-main.o3`, err));
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.runtime) {
                    return mod.runtime(`mutation:${id}`, ctx).catch((err) => Ogone.error(err.message, `Error in commit. mutation: ${id} component: examples/app/components/menu/menu-main.o3`, err));
                }
            }
        },
        get: (id) => {
            const path = id.split('/');
            if (path.length > 1) {
                const [namespace, get] = path;
                const mod = this.store[namespace];
                if (mod && mod.data) {
                    return mod.data[get];
                }
            }
            else {
                const mod = this.store[null];
                if (mod && mod.data) {
                    return mod.data[id];
                }
            }
        },
    };
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "isOpen": false, "menu": [{ "name": "Introduction", "route": "/intro" }, { "name": "Ogone theory", "route": "/theory" }, { "name": "Documentation", "route": "/doc", "children": [{ "name": "Install", "route": "/doc/install" }, { "name": "Get Started", "route": "/doc/get-started" }, { "name": "Flags", "route": "/flags", "children": [{ "name": "--if --else --else-if", "status": "ok" }, { "name": "--for", "status": "ok" }, { "name": "--await --defer", "status": "in-progress" }, { "name": "--then:...", "status": "ok" }, { "name": "--catch:...", "status": "ok" }, { "name": "--finally:...", "status": "ok" }, { "name": "--class --style", "status": "ok" }, { "name": "--anim", "status": "todo" }, { "name": "--router-go", "status": "ok" }, { "name": "--<DOM L3>:..", "status": "ok" }, { "name": "--drag:...", "status": "todo" }, { "name": "--dragstart:...", "status": "todo" }, { "name": "--dragend:...", "status": "todo" }] }, { "name": "Components", "route": "/doc/components", "status": "ok", "children": [{ "name": "Components Anatomy", "route": "/doc/components/components-anatomy" }, { "name": "Counter", "route": "/doc/components/counter" }, { "name": "Greeting App", "route": "/doc/components/cgc" }, { "name": "Recursive Tree Button", "route": "/doc/components/rtb" }] }, { "name": "Async Components", "status": "in-progress", "route": "/doc/async-components" }, { "name": "Router", "route": "/doc/router", "status": "in-progress", "children": [{ "name": "Router anatomy", "route": "/doc/router/router-anatomy" }] }, { "name": "Store", "status": "in-progress", "route": "/doc/store", "children": [{ "name": "Store anatomy", "route": "/doc/store/store-anatomy" }] }, { "name": "Controllers", "status": "in-progress", "route": "/doc/controllers", "children": [{ "name": "Controllers anatomy", "route": "/doc/controllers/controllers-anatomy" }] }, { "name": "Api", "route": "/api", "children": [{ "name": "Refs", "status": "in-progress" }, { "name": "Store", "status": "in-progress" }, { "name": "Async", "status": "in-progress" }, { "name": "Tests Cases", "status": "todo" }] }] }, { "name": "Project", "route": "/project" }, { "name": "Todos", "route": "/todos" }, { "name": "Support", "route": "/support" }] };
    this.refs = {};
    const Refs = this.refs;
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && !['click:toggle-menu'].includes(_state)) {
                return;
            }
            switch (_state) {
                case 'click:toggle-menu':
                    Store.dispatch('menu/toggle');
                    break;
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/components/menu/menu-main.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-avsnr'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "openTree": false, "item": null };
    this.refs = {};
    const Refs = this.refs;
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && !['click:toggle'].includes(_state)) {
                return;
            }
            switch (_state) {
                case 'click:toggle':
                    this.openTree = !this.openTree;
                    ____('openTree', this);
                    break;
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/app/components/menu/tree-recursive-button.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-xsano'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = {};
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.components['data-zbnay'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = {};
    this.refs = {};
    const Refs = this.refs;
    const __run = function () { };
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.render['data-555ax-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-555ax', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('div'); if (position)
    position[level] = index; n4.setAttribute('data-555ax', ''); n4.setAttribute('id', 'header'); n4.setAttribute('class', 'header'); n4.append((function (ctx, position = [], index = 0, level = 0) { const n5 = document.createElement('div'); if (position)
    position[level] = index; n5.setAttribute('data-555ax', ''); n5.setAttribute('class', 'logo'); n5.append((function (ctx, position = [], index = 0, level = 0) { const nd6 = document.createElement('template', { is: 'data-3vbxo-nt' }); if (position)
    position[level] = index; nd6.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-555ax-nd6', dependencies: ["'/'"], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "name": "router-go", "eval": "'/'" }], "elseIf": "", "finally": "", "else": false }, }); nd6.setAttribute('data-555ax', ''); return nd6; })(ctx, position.slice(), index, level + 1)); return n5; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n9 = document.createElement('template', { is: 'data-5zxav-nt' }); if (position)
    position[level] = index; n9.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-555ax-n9', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n9.setAttribute('data-555ax', ''); return n9; })(ctx, position.slice(), index, level + 1)); return n4; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n11 = document.createElement('template', { is: 'data-z3yrn-nt' }); if (position)
    position[level] = index; n11.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-555ax-n11', dependencies: ["new"], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n11.setAttribute('data-555ax', ''); n11.setAttribute('name', 'new'); return n11; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n12 = document.createElement('template', { is: 'data-s3sox-nt' }); if (position)
    position[level] = index; n12.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-555ax-n12', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n12.setAttribute('data-555ax', ''); return n12; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd13 = document.createElement('template', { is: 'data-oyzy5-nt' }); if (position)
    position[level] = index; nd13.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-555ax-nd13', dependencies: ["scrollY"], props: ([["test", "scrollY"]]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd13.setAttribute('data-555ax', ''); return nd13; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-xxnzv-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-xxnzv', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-xxnzv', ''); n3.setAttribute('class', 'container'); n3.append((function (ctx, position = [], index = 0, level = 0) { const nd4 = document.createElement('template', { is: 'data-5b3rz-nt' }); if (position)
    position[level] = index; nd4.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-xxnzv-nd4', dependencies: ["articles as (article)", "article.text", "article.title", "article.code"], props: ([["text", "article.text"], ["title", "article.title"], ["code", "article.code"]]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd4.setAttribute('data-xxnzv', ''); return nd4; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-5b3rz-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-5b3rz', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-5b3rz', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-5b3rz', ''); n3.setAttribute('class', 'left'); n3.append((function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('h2'); if (position)
    position[level] = index; n4.setAttribute('data-5b3rz', ''); n4.setAttribute('class', 'title'); n4.append((function (ctx, position = [], index = 0, level = 0) { const t10 = new Text(' '); const g = Ogone.contexts['data-5b3rz-t10'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${title}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t10.data && t10.data !== v)
    t10.data = v; return true; } ; ctx.texts.push(r); return t10; })(ctx, position.slice())); return n4; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('p'); if (position)
    position[level] = index; n6.setAttribute('data-5b3rz', ''); n6.setAttribute('class', 'text'); n6.append((function (ctx, position = [], index = 0, level = 0) { const t15 = new Text(' '); const g = Ogone.contexts['data-5b3rz-t15'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${text}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t15.data && t15.data !== v)
    t15.data = v; return true; } ; ctx.texts.push(r); return t15; })(ctx, position.slice())); return n6; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n9 = document.createElement('div'); if (position)
    position[level] = index; n9.setAttribute('data-5b3rz', ''); n9.setAttribute('class', 'right'); n9.append((function (ctx, position = [], index = 0, level = 0) { const n10 = document.createElement('pre'); if (position)
    position[level] = index; n10.setAttribute('data-5b3rz', ''); n10.append((function (ctx, position = [], index = 0, level = 0) { const n11 = document.createElement('code'); if (position)
    position[level] = index; n11.setAttribute('data-5b3rz', ''); n11.append((function (ctx, position = [], index = 0, level = 0) { const t26 = new Text(' '); const g = Ogone.contexts['data-5b3rz-t26'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${code}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t26.data && t26.data !== v)
    t26.data = v; return true; } ; ctx.texts.push(r); return t26; })(ctx, position.slice())); return n11; })(ctx, position.slice(), index, level + 1)); return n10; })(ctx, position.slice(), index, level + 1)); return n9; })(ctx, position.slice(), index, level + 1)); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-oyzy5-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-oyzy5', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-oyzy5', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const t6 = new Text(' '); const g = Ogone.contexts['data-oyzy5-t6'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${test}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t6.data && t6.data !== v)
    t6.data = v; return true; } ; ctx.texts.push(r); return t6; })(ctx, position.slice())); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-3vbxo-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-3vbxo', ''); nt.append((function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-3vbxo', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-3vbxo', ''); n3.setAttribute('class', 'logo-back'); n3.append((function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('img'); if (position)
    position[level] = index; n4.setAttribute('data-3vbxo', ''); n4.setAttribute('class', 'img'); n4.setAttribute('src', '/public/ogone.svg'); return n4; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1)); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-5zxav-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-5zxav', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-5zxav', ''); n3.setAttribute('id', 'test'); n3.setAttribute('class', 'menu'); n3.append((function (ctx, position = [], index = 0, level = 0) { const nd4 = document.createElement('template', { is: 'data-x33ao-nt' }); if (position)
    position[level] = index; nd4.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-5zxav-nd4', dependencies: ["menu as (t)", "t"], props: ([["item", "t"]]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd4.setAttribute('data-5zxav', ''); return nd4; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n5 = document.createElement('div'); if (position)
    position[level] = index; n5.setAttribute('data-5zxav', ''); n5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('template', { is: 'data-yoanx-nt' }); if (position)
    position[level] = index; n6.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-5zxav-n6', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n6.setAttribute('data-5zxav', ''); return n6; })(ctx, position.slice(), index, level + 1)); return n5; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-yoanx-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-yoanx', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('template', { is: 'data-35zxv-nt' }); if (position)
    position[level] = index; n2.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-yoanx-n2', dependencies: ["menu"], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n2.setAttribute('data-yoanx', ''); n2.setAttribute('namespace', 'menu'); return n2; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement("data-yoanx-nd5"); if (position)
    position[level] = index; nd5.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "case": "click:openMenu", "filter": null, "target": null }], "elseIf": "", "finally": "", "else": false }, }); nd5.setAttribute('data-yoanx', ''); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('div'); if (position)
    position[level] = index; n6.setAttribute('data-yoanx', ''); n6.setAttribute('class', 'line'); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n8 = document.createElement('div'); if (position)
    position[level] = index; n8.setAttribute('data-yoanx', ''); n8.setAttribute('class', 'line'); return n8; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n10 = document.createElement('div'); if (position)
    position[level] = index; n10.setAttribute('data-yoanx', ''); n10.setAttribute('class', 'line'); return n10; })(ctx, position.slice(), index, level + 1)); return nd5; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-yoanx-nd5'] = (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement('div'); if (position)
    position[level] = index; nd5.setAttribute('data-yoanx', ''); nd5.setAttribute('class', 'container'); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('div'); if (position)
    position[level] = index; n6.setAttribute('data-yoanx', ''); n6.setAttribute('class', 'line'); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n8 = document.createElement('div'); if (position)
    position[level] = index; n8.setAttribute('data-yoanx', ''); n8.setAttribute('class', 'line'); return n8; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n10 = document.createElement('div'); if (position)
    position[level] = index; n10.setAttribute('data-yoanx', ''); n10.setAttribute('class', 'line'); return n10; })(ctx, position.slice(), index, level + 1)); return nd5; });
Ogone.render['data-35zxv-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-35zxv', ''); return nt; });
Ogone.render['data-x33ao-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-x33ao', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const nd2 = document.createElement("data-x33ao-nd2"); if (position)
    position[level] = index; nd2.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "name": "router-go", "eval": "item.route" }], "elseIf": "", "finally": "", "else": false }, }); nd2.setAttribute('data-x33ao', ''); nd2.append((function (ctx, position = [], index = 0, level = 0) { const t6 = new Text(' '); const g = Ogone.contexts['data-x33ao-t6'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${item.name}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t6.data && t6.data !== v)
    t6.data = v; return true; } ; ctx.texts.push(r); return t6; })(ctx, position.slice()), (function (ctx, position = [], index = 0, level = 0) { const nd3 = document.createElement("data-x33ao-nd3"); if (position)
    position[level] = index; nd3.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'ok'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd3.setAttribute('data-x33ao', ''); return nd3; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement("data-x33ao-nd5"); if (position)
    position[level] = index; nd5.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'todo'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd5.setAttribute('data-x33ao', ''); return nd5; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd7 = document.createElement("data-x33ao-nd7"); if (position)
    position[level] = index; nd7.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'in-progress'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd7.setAttribute('data-x33ao', ''); return nd7; })(ctx, position.slice(), index, level + 1)); return nd2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-x33ao-nd2'] = (function (ctx, position = [], index = 0, level = 0) { const nd2 = document.createElement('div'); if (position)
    position[level] = index; nd2.setAttribute('data-x33ao', ''); nd2.setAttribute('class', 'container'); nd2.append((function (ctx, position = [], index = 0, level = 0) { const t6 = new Text(' '); const g = Ogone.contexts['data-x33ao-t6'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${item.name}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t6.data && t6.data !== v)
    t6.data = v; return true; } ; ctx.texts.push(r); return t6; })(ctx, position.slice()), (function (ctx, position = [], index = 0, level = 0) { const nd3 = document.createElement("data-x33ao-nd3"); if (position)
    position[level] = index; nd3.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'ok'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd3.setAttribute('data-x33ao', ''); return nd3; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement("data-x33ao-nd5"); if (position)
    position[level] = index; nd5.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'todo'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd5.setAttribute('data-x33ao', ''); return nd5; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd7 = document.createElement("data-x33ao-nd7"); if (position)
    position[level] = index; nd7.setOgone({ position, level, index, component: ctx, flags: { "if": "item.status === 'in-progress'", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd7.setAttribute('data-x33ao', ''); return nd7; })(ctx, position.slice(), index, level + 1)); return nd2; });
Ogone.render['data-x33ao-nd3'] = (function (ctx, position = [], index = 0, level = 0) { const nd3 = document.createElement('span'); if (position)
    position[level] = index; nd3.setAttribute('data-x33ao', ''); nd3.setAttribute('class', 'ok'); return nd3; });
Ogone.render['data-x33ao-nd5'] = (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement('span'); if (position)
    position[level] = index; nd5.setAttribute('data-x33ao', ''); nd5.setAttribute('class', 'todo'); return nd5; });
Ogone.render['data-x33ao-nd7'] = (function (ctx, position = [], index = 0, level = 0) { const nd7 = document.createElement('span'); if (position)
    position[level] = index; nd7.setAttribute('data-x33ao', ''); nd7.setAttribute('class', 'in-progress'); return nd7; });
Ogone.render['data-z3yrn-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-z3yrn', ''); nt.append(``); return nt; });
Ogone.render['data-o3sab-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-o3sab', ''); nt.append((function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-o3sab', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-o3sab', ''); n3.setAttribute('class', 'logo-back'); n3.append((function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('img'); if (position)
    position[level] = index; n4.setAttribute('data-o3sab', ''); n4.setAttribute('class', 'logo'); n4.setAttribute('src', '/public/ogone.svg'); return n4; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('div'); if (position)
    position[level] = index; n6.setAttribute('data-o3sab', ''); n6.setAttribute('class', 'text'); n6.append(`404 route not found.`); return n6; })(ctx, position.slice(), index, level + 1)); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-s3sox-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-s3sox', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('template', { is: 'data-35zxv-nt' }); if (position)
    position[level] = index; n2.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-s3sox-n2', dependencies: ["menu"], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n2.setAttribute('data-s3sox', ''); n2.setAttribute('namespace', 'menu'); return n2; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement("data-s3sox-nd5"); if (position)
    position[level] = index; nd5.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "{ close: !isOpen }", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd5.setAttribute('data-s3sox', ''); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('div'); if (position)
    position[level] = index; n6.setAttribute('data-s3sox', ''); n6.setAttribute('class', 'header'); n6.append((function (ctx, position = [], index = 0, level = 0) { const nd7 = document.createElement('template', { is: 'data-zbnay-nt' }); if (position)
    position[level] = index; nd7.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-s3sox-nd7', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "case": "click:toggle-menu", "filter": null, "target": null }], "elseIf": "", "finally": "", "else": false }, }); nd7.setAttribute('data-s3sox', ''); return nd7; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n9 = document.createElement('div'); if (position)
    position[level] = index; n9.setAttribute('data-s3sox', ''); n9.append(`0.1.0`); return n9; })(ctx, position.slice(), index, level + 1)); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n12 = document.createElement('div'); if (position)
    position[level] = index; n12.setAttribute('data-s3sox', ''); n12.setAttribute('class', 'tree'); n12.append((function (ctx, position = [], index = 0, level = 0) { const nd13 = document.createElement('template', { is: 'data-avsnr-nt' }); if (position)
    position[level] = index; nd13.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-s3sox-nd13', dependencies: ["menu as (item)", "item"], props: ([["item", "item"]]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd13.setAttribute('data-s3sox', ''); return nd13; })(ctx, position.slice(), index, level + 1)); return n12; })(ctx, position.slice(), index, level + 1)); return nd5; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd17 = document.createElement("data-s3sox-nd17"); if (position)
    position[level] = index; nd17.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "{ darken: isOpen }", "catch": "", "events": [{ "type": "click", "case": "click:toggle-menu", "filter": null, "target": null }], "elseIf": "", "finally": "", "else": false }, }); nd17.setAttribute('data-s3sox', ''); return nd17; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-s3sox-nd5'] = (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement('div'); if (position)
    position[level] = index; nd5.setAttribute('data-s3sox', ''); nd5.setAttribute('class', 'left-menu'); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('div'); if (position)
    position[level] = index; n6.setAttribute('data-s3sox', ''); n6.setAttribute('class', 'header'); n6.append((function (ctx, position = [], index = 0, level = 0) { const nd7 = document.createElement('template', { is: 'data-zbnay-nt' }); if (position)
    position[level] = index; nd7.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-s3sox-nd7', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "case": "click:toggle-menu", "filter": null, "target": null }], "elseIf": "", "finally": "", "else": false }, }); nd7.setAttribute('data-s3sox', ''); return nd7; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n9 = document.createElement('div'); if (position)
    position[level] = index; n9.setAttribute('data-s3sox', ''); n9.append(`0.1.0`); return n9; })(ctx, position.slice(), index, level + 1)); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const n12 = document.createElement('div'); if (position)
    position[level] = index; n12.setAttribute('data-s3sox', ''); n12.setAttribute('class', 'tree'); n12.append((function (ctx, position = [], index = 0, level = 0) { const nd13 = document.createElement('template', { is: 'data-avsnr-nt' }); if (position)
    position[level] = index; nd13.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-s3sox-nd13', dependencies: ["menu as (item)", "item"], props: ([["item", "item"]]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd13.setAttribute('data-s3sox', ''); return nd13; })(ctx, position.slice(), index, level + 1)); return n12; })(ctx, position.slice(), index, level + 1)); return nd5; });
Ogone.render['data-s3sox-nd17'] = (function (ctx, position = [], index = 0, level = 0) { const nd17 = document.createElement('div'); if (position)
    position[level] = index; nd17.setAttribute('data-s3sox', ''); return nd17; });
Ogone.render['data-avsnr-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-avsnr', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('div'); if (position)
    position[level] = index; n4.setAttribute('data-avsnr', ''); n4.setAttribute('class', 'container'); n4.append((function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement("data-avsnr-nd5"); if (position)
    position[level] = index; nd5.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [{ "type": "click", "case": "click:toggle", "filter": null, "target": null }, { "type": "click", "name": "router-go", "eval": "item.route" }], "elseIf": "", "finally": "", "else": false }, }); nd5.setAttribute('data-avsnr', ''); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('span'); if (position)
    position[level] = index; n6.setAttribute('data-avsnr', ''); n6.append((function (ctx, position = [], index = 0, level = 0) { const t15 = new Text(' '); const g = Ogone.contexts['data-avsnr-t15'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${item.name}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t15.data && t15.data !== v)
    t15.data = v; return true; } ; ctx.texts.push(r); return t15; })(ctx, position.slice())); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd8 = document.createElement("data-avsnr-nd8"); if (position)
    position[level] = index; nd8.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "!item.children && item.status ? `status ${item.status}` : ''", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd8.setAttribute('data-avsnr', ''); nd8.append((function (ctx, position = [], index = 0, level = 0) { const t20 = new Text(' '); const g = Ogone.contexts['data-avsnr-t20'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${!item.children && item.status ? item.status : \'\'}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t20.data && t20.data !== v)
    t20.data = v; return true; } ; ctx.texts.push(r); return t20; })(ctx, position.slice())); return nd8; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd10 = document.createElement("data-avsnr-nd10"); if (position)
    position[level] = index; nd10.setOgone({ position, level, index, component: ctx, flags: { "if": "item.children && !openTree", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd10.setAttribute('data-avsnr', ''); nd10.append(`>`); return nd10; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd12 = document.createElement("data-avsnr-nd12"); if (position)
    position[level] = index; nd12.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "item.children && openTree", "finally": "", "else": false }, }); nd12.setAttribute('data-avsnr', ''); nd12.append(`<`); return nd12; })(ctx, position.slice(), index, level + 1)); return nd5; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd15 = document.createElement("data-avsnr-nd15"); if (position)
    position[level] = index; nd15.setOgone({ position, level, index, component: ctx, flags: { "if": "item.children", "then": "", "defer": "", "await": "", "style": "", "class": "{ 'child-open': openTree }", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd15.setAttribute('data-avsnr', ''); nd15.append((function (ctx, position = [], index = 0, level = 0) { const n16 = document.createElement('template', { is: 'data-xsano-nt' }); if (position)
    position[level] = index; n16.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-avsnr-n16', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n16.setAttribute('data-avsnr', ''); n16.append((function (ctx, position = [], index = 0, level = 0) { const nd17 = document.createElement('template', { is: 'data-avsnr-nt' }); if (position)
    position[level] = index; nd17.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-avsnr-nd17', dependencies: ["!!item.children", "item.children as (child)", "child ? child : {}"], props: ([["item", "child ? child : {}"]]), flags: { "if": "!!item.children", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd17.setAttribute('data-avsnr', ''); return nd17; })(ctx, position.slice(), index, level + 1)); return n16; })(ctx, position.slice(), index, level + 1)); return nd15; })(ctx, position.slice(), index, level + 1)); return n4; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-avsnr-nd5'] = (function (ctx, position = [], index = 0, level = 0) { const nd5 = document.createElement('div'); if (position)
    position[level] = index; nd5.setAttribute('data-avsnr', ''); nd5.setAttribute('class', 'title'); nd5.append((function (ctx, position = [], index = 0, level = 0) { const n6 = document.createElement('span'); if (position)
    position[level] = index; n6.setAttribute('data-avsnr', ''); n6.append((function (ctx, position = [], index = 0, level = 0) { const t15 = new Text(' '); const g = Ogone.contexts['data-avsnr-t15'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${item.name}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t15.data && t15.data !== v)
    t15.data = v; return true; } ; ctx.texts.push(r); return t15; })(ctx, position.slice())); return n6; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd8 = document.createElement("data-avsnr-nd8"); if (position)
    position[level] = index; nd8.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "!item.children && item.status ? `status ${item.status}` : ''", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd8.setAttribute('data-avsnr', ''); nd8.append((function (ctx, position = [], index = 0, level = 0) { const t20 = new Text(' '); const g = Ogone.contexts['data-avsnr-t20'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${!item.children && item.status ? item.status : \'\'}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t20.data && t20.data !== v)
    t20.data = v; return true; } ; ctx.texts.push(r); return t20; })(ctx, position.slice())); return nd8; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd10 = document.createElement("data-avsnr-nd10"); if (position)
    position[level] = index; nd10.setOgone({ position, level, index, component: ctx, flags: { "if": "item.children && !openTree", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd10.setAttribute('data-avsnr', ''); nd10.append(`>`); return nd10; })(ctx, position.slice(), index, level + 1), (function (ctx, position = [], index = 0, level = 0) { const nd12 = document.createElement("data-avsnr-nd12"); if (position)
    position[level] = index; nd12.setOgone({ position, level, index, component: ctx, flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "item.children && openTree", "finally": "", "else": false }, }); nd12.setAttribute('data-avsnr', ''); nd12.append(`<`); return nd12; })(ctx, position.slice(), index, level + 1)); return nd5; });
Ogone.render['data-avsnr-nd8'] = (function (ctx, position = [], index = 0, level = 0) { const nd8 = document.createElement('span'); if (position)
    position[level] = index; nd8.setAttribute('data-avsnr', ''); nd8.append((function (ctx, position = [], index = 0, level = 0) { const t20 = new Text(' '); const g = Ogone.contexts['data-avsnr-t20'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`${!item.children && item.status ? item.status : \'\'}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t20.data && t20.data !== v)
    t20.data = v; return true; } ; ctx.texts.push(r); return t20; })(ctx, position.slice())); return nd8; });
Ogone.render['data-avsnr-nd10'] = (function (ctx, position = [], index = 0, level = 0) { const nd10 = document.createElement('span'); if (position)
    position[level] = index; nd10.setAttribute('data-avsnr', ''); nd10.append(`>`); return nd10; });
Ogone.render['data-avsnr-nd12'] = (function (ctx, position = [], index = 0, level = 0) { const nd12 = document.createElement('span'); if (position)
    position[level] = index; nd12.setAttribute('data-avsnr', ''); nd12.append(`<`); return nd12; });
Ogone.render['data-avsnr-nd15'] = (function (ctx, position = [], index = 0, level = 0) { const nd15 = document.createElement('div'); if (position)
    position[level] = index; nd15.setAttribute('data-avsnr', ''); nd15.setAttribute('class', 'child'); nd15.append((function (ctx, position = [], index = 0, level = 0) { const n16 = document.createElement('template', { is: 'data-xsano-nt' }); if (position)
    position[level] = index; n16.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-avsnr-n16', dependencies: [], props: ([]), flags: { "if": "", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); n16.setAttribute('data-avsnr', ''); n16.append((function (ctx, position = [], index = 0, level = 0) { const nd17 = document.createElement('template', { is: 'data-avsnr-nt' }); if (position)
    position[level] = index; nd17.setOgone({ positionInParentComponent: position, levelInParentComponent: level, parentComponent: ctx, parentCTXId: 'data-avsnr-nd17', dependencies: ["!!item.children", "item.children as (child)", "child ? child : {}"], props: ([["item", "child ? child : {}"]]), flags: { "if": "!!item.children", "then": "", "defer": "", "await": "", "style": "", "class": "", "catch": "", "events": [], "elseIf": "", "finally": "", "else": false }, }); nd17.setAttribute('data-avsnr', ''); return nd17; })(ctx, position.slice(), index, level + 1)); return n16; })(ctx, position.slice(), index, level + 1)); return nd15; });
Ogone.render['data-xsano-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-xsano', ''); nt.append((function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-xsano', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-xsano', ''); ctx.refs['view'] = n3; n3.setAttribute('class', 'view'); n3.append((function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('div'); if (position)
    position[level] = index; n4.setAttribute('data-xsano', ''); ctx.refs['content'] = n4; n4.setAttribute('class', 'content'); n4.append((function (ctx, position = [], index = 0, level = 0) { const n5 = document.createElement('slot'); if (position)
    position[level] = index; n5.setAttribute('data-xsano', ''); return n5; })(ctx, position.slice(), index, level + 1)); return n4; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1)); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.render['data-zbnay-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-zbnay', ''); nt.append((function (ctx, position = [], index = 0, level = 0) { const n2 = document.createElement('div'); if (position)
    position[level] = index; n2.setAttribute('data-zbnay', ''); n2.setAttribute('class', 'container'); n2.append((function (ctx, position = [], index = 0, level = 0) { const n3 = document.createElement('div'); if (position)
    position[level] = index; n3.setAttribute('data-zbnay', ''); n3.setAttribute('class', 'logo-back'); n3.append((function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('img'); if (position)
    position[level] = index; n4.setAttribute('data-zbnay', ''); n4.setAttribute('class', 'img'); n4.setAttribute('src', '/public/ogone.svg'); return n4; })(ctx, position.slice(), index, level + 1)); return n3; })(ctx, position.slice(), index, level + 1)); return n2; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.contexts['data-zbnay-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/logo.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return {};
};
Ogone.contexts['data-zbnay-n2'] = Ogone.contexts['data-zbnay-nt'];
Ogone.contexts['data-zbnay-n3'] = Ogone.contexts['data-zbnay-n2'];
Ogone.contexts['data-zbnay-n4'] = Ogone.contexts['data-zbnay-n3'];
Ogone.contexts['data-xsano-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/scroll.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return {};
};
Ogone.contexts['data-xsano-n2'] = Ogone.contexts['data-xsano-nt'];
Ogone.contexts['data-xsano-n3'] = Ogone.contexts['data-xsano-n2'];
Ogone.contexts['data-xsano-n4'] = Ogone.contexts['data-xsano-n3'];
Ogone.contexts['data-xsano-n5'] = Ogone.contexts['data-xsano-n4'];
Ogone.contexts['data-avsnr-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-avsnr-n4'] = Ogone.contexts['data-avsnr-nt'];
Ogone.contexts['data-avsnr-nd15'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_LENGTH && !(item.children)) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-avsnr-n16'] = Ogone.contexts['data-avsnr-nd15'];
Ogone.contexts['data-avsnr-nd17'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    const _____a_ = item.children || [];
    let i2 = POSITION[4], child = (_____a_)[i2];
    let _____a_2 = _____a_.filter((child, i2) => (!!item.children));
    child = (_____a_2)[i2];
    if (GET_LENGTH) {
        return (_____a_2).length;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { i2, child, openTree, item };
};
Ogone.contexts['data-avsnr-nd5'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-avsnr-nd12'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_LENGTH && (item.children && !openTree)) {
        return 0;
    }
    else if (GET_LENGTH && !(item.children && openTree)) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-avsnr-t30'] = Ogone.contexts['data-avsnr-nd12'];
Ogone.contexts['data-avsnr-nd10'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_LENGTH && !(item.children && !openTree)) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-avsnr-t25'] = Ogone.contexts['data-avsnr-nd10'];
Ogone.contexts['data-avsnr-nd8'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const openTree = this.openTree;
    const item = this.item;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/tree-recursive-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { openTree, item };
};
Ogone.contexts['data-avsnr-t20'] = Ogone.contexts['data-avsnr-nd8'];
Ogone.contexts['data-avsnr-n6'] = Ogone.contexts['data-avsnr-nd5'];
Ogone.contexts['data-avsnr-t15'] = Ogone.contexts['data-avsnr-n6'];
Ogone.contexts['data-avsnr-t3'] = Ogone.contexts['data-avsnr-nt'];
Ogone.contexts['data-s3sox-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    const menu = this.menu;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-main.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen, menu };
};
Ogone.contexts['data-s3sox-nd17'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    const menu = this.menu;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-main.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen, menu };
};
Ogone.contexts['data-s3sox-nd5'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    const menu = this.menu;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-main.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen, menu };
};
Ogone.contexts['data-s3sox-n12'] = Ogone.contexts['data-s3sox-nd5'];
Ogone.contexts['data-s3sox-nd13'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    const menu = this.menu;
    const _____a_ = menu || [];
    let i1 = POSITION[3], item = (_____a_)[i1];
    if (GET_LENGTH) {
        return (_____a_).length;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-main.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { i1, item, isOpen, menu };
};
Ogone.contexts['data-s3sox-n6'] = Ogone.contexts['data-s3sox-nd5'];
Ogone.contexts['data-s3sox-n9'] = Ogone.contexts['data-s3sox-n6'];
Ogone.contexts['data-s3sox-t21'] = Ogone.contexts['data-s3sox-n9'];
Ogone.contexts['data-s3sox-nd7'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    const menu = this.menu;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-main.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen, menu };
};
Ogone.contexts['data-s3sox-n2'] = Ogone.contexts['data-s3sox-nt'];
Ogone.contexts['data-s3sox-t3'] = Ogone.contexts['data-s3sox-nt'];
Ogone.contexts['data-o3sab-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/404.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return {};
};
Ogone.contexts['data-o3sab-n2'] = Ogone.contexts['data-o3sab-nt'];
Ogone.contexts['data-o3sab-n6'] = Ogone.contexts['data-o3sab-n2'];
Ogone.contexts['data-o3sab-t13'] = Ogone.contexts['data-o3sab-n6'];
Ogone.contexts['data-o3sab-n3'] = Ogone.contexts['data-o3sab-n2'];
Ogone.contexts['data-o3sab-n4'] = Ogone.contexts['data-o3sab-n3'];
Ogone.contexts['data-z3yrn-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/routers/.router.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return {};
};
Ogone.contexts['data-z3yrn-t3'] = Ogone.contexts['data-z3yrn-nt'];
Ogone.contexts['data-x33ao-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const item = this.item;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { item };
};
Ogone.contexts['data-x33ao-nd2'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const item = this.item;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { item };
};
Ogone.contexts['data-x33ao-nd7'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const item = this.item;
    if (GET_LENGTH && !(item.status === 'in-progress')) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { item };
};
Ogone.contexts['data-x33ao-nd5'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const item = this.item;
    if (GET_LENGTH && !(item.status === 'todo')) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { item };
};
Ogone.contexts['data-x33ao-nd3'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const item = this.item;
    if (GET_LENGTH && !(item.status === 'ok')) {
        return 0;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-button.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { item };
};
Ogone.contexts['data-x33ao-t6'] = Ogone.contexts['data-x33ao-nd2'];
Ogone.contexts['data-x33ao-t3'] = Ogone.contexts['data-x33ao-nt'];
Ogone.contexts['data-35zxv-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/stores/menu.store.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen };
};
Ogone.contexts['data-yoanx-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/burger.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen };
};
Ogone.contexts['data-yoanx-nd5'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const isOpen = this.isOpen;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/burger.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { isOpen };
};
Ogone.contexts['data-yoanx-n10'] = Ogone.contexts['data-yoanx-nd5'];
Ogone.contexts['data-yoanx-n8'] = Ogone.contexts['data-yoanx-nd5'];
Ogone.contexts['data-yoanx-n6'] = Ogone.contexts['data-yoanx-nd5'];
Ogone.contexts['data-yoanx-n2'] = Ogone.contexts['data-yoanx-nt'];
Ogone.contexts['data-yoanx-t3'] = Ogone.contexts['data-yoanx-nt'];
Ogone.contexts['data-5zxav-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const menu = this.menu;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-content.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { menu };
};
Ogone.contexts['data-5zxav-n3'] = Ogone.contexts['data-5zxav-nt'];
Ogone.contexts['data-5zxav-n5'] = Ogone.contexts['data-5zxav-n3'];
Ogone.contexts['data-5zxav-n6'] = Ogone.contexts['data-5zxav-n5'];
Ogone.contexts['data-5zxav-nd4'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const menu = this.menu;
    const _____a_ = menu || [];
    let i0 = POSITION[2], t = (_____a_)[i0];
    if (GET_LENGTH) {
        return (_____a_).length;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/menu/menu-content.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { i0, t, menu };
};
Ogone.contexts['data-5zxav-t3'] = Ogone.contexts['data-5zxav-nt'];
Ogone.contexts['data-3vbxo-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/asyncs/logo.async.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return {};
};
Ogone.contexts['data-3vbxo-n2'] = Ogone.contexts['data-3vbxo-nt'];
Ogone.contexts['data-3vbxo-n3'] = Ogone.contexts['data-3vbxo-n2'];
Ogone.contexts['data-3vbxo-n4'] = Ogone.contexts['data-3vbxo-n3'];
Ogone.contexts['data-oyzy5-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const test = this.test;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/left-menu.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { test };
};
Ogone.contexts['data-oyzy5-n2'] = Ogone.contexts['data-oyzy5-nt'];
Ogone.contexts['data-oyzy5-t6'] = Ogone.contexts['data-oyzy5-n2'];
Ogone.contexts['data-oyzy5-t3'] = Ogone.contexts['data-oyzy5-nt'];
Ogone.contexts['data-5b3rz-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const title = this.title;
    const text = this.text;
    const code = this.code;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/components/content.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { title, text, code };
};
Ogone.contexts['data-5b3rz-n2'] = Ogone.contexts['data-5b3rz-nt'];
Ogone.contexts['data-5b3rz-n9'] = Ogone.contexts['data-5b3rz-n2'];
Ogone.contexts['data-5b3rz-n10'] = Ogone.contexts['data-5b3rz-n9'];
Ogone.contexts['data-5b3rz-n11'] = Ogone.contexts['data-5b3rz-n10'];
Ogone.contexts['data-5b3rz-t26'] = Ogone.contexts['data-5b3rz-n11'];
Ogone.contexts['data-5b3rz-n3'] = Ogone.contexts['data-5b3rz-n2'];
Ogone.contexts['data-5b3rz-n6'] = Ogone.contexts['data-5b3rz-n3'];
Ogone.contexts['data-5b3rz-t15'] = Ogone.contexts['data-5b3rz-n6'];
Ogone.contexts['data-5b3rz-n4'] = Ogone.contexts['data-5b3rz-n3'];
Ogone.contexts['data-5b3rz-t10'] = Ogone.contexts['data-5b3rz-n4'];
Ogone.contexts['data-5b3rz-t3'] = Ogone.contexts['data-5b3rz-nt'];
Ogone.contexts['data-xxnzv-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const articles = this.articles;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/pages/body.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { articles };
};
Ogone.contexts['data-xxnzv-n3'] = Ogone.contexts['data-xxnzv-nt'];
Ogone.contexts['data-xxnzv-nd4'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const articles = this.articles;
    const _____a_ = articles || [];
    let i0 = POSITION[2], article = (_____a_)[i0];
    if (GET_LENGTH) {
        return (_____a_).length;
    }
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/pages/body.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { i0, article, articles };
};
Ogone.contexts['data-xxnzv-t3'] = Ogone.contexts['data-xxnzv-nt'];
Ogone.contexts['data-555ax-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const scrollY = this.scrollY;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/index.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { scrollY };
};
Ogone.contexts['data-555ax-nd13'] = Ogone.contexts['data-555ax-nt'];
Ogone.contexts['data-555ax-n12'] = Ogone.contexts['data-555ax-nt'];
Ogone.contexts['data-555ax-n11'] = Ogone.contexts['data-555ax-nt'];
Ogone.contexts['data-555ax-n4'] = Ogone.contexts['data-555ax-nt'];
Ogone.contexts['data-555ax-n9'] = Ogone.contexts['data-555ax-n4'];
Ogone.contexts['data-555ax-n5'] = Ogone.contexts['data-555ax-n4'];
Ogone.contexts['data-555ax-nd6'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const scrollY = this.scrollY;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/app/index.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { scrollY };
};
Ogone.contexts['data-555ax-t3'] = Ogone.contexts['data-555ax-nt'];
Ogone.classes['data-zbnay-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-zbnay']();
        component.requirements = (null);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-zbnay'] = Ogone.run['data-zbnay'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-zbnay-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-zbnay-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-xsano-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-xsano']();
        component.requirements = (null);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-xsano'] = Ogone.run['data-xsano'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-xsano-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-xsano-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-avsnr-nd15'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item", "openTree"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd15' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-avsnr-nd15';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-avsnr-nd15'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-avsnr-nd12'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["openTree", "item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd12' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-avsnr-nd12';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-avsnr-nd12'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-avsnr-nd10'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["openTree", "item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd10' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-avsnr-nd10';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-avsnr-nd10'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-avsnr-nd8'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd8' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-avsnr-nd8';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-avsnr-nd8'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-avsnr-nd5'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd5' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-avsnr-nd5';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-avsnr-nd5'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-avsnr-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-avsnr']();
        component.requirements = ([["item", ["Object"]]]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-avsnr'] = Ogone.run['data-avsnr'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-avsnr-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-avsnr-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-s3sox-nd17'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["isOpen"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd17' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-s3sox-nd17';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-s3sox-nd17'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-s3sox-nd5'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["isOpen"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd5' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-s3sox-nd5';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-s3sox-nd5'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-s3sox-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-s3sox']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-s3sox'] = Ogone.run['data-s3sox'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-s3sox-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-s3sox-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-o3sab-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-o3sab']();
        component.requirements = (null);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-o3sab'] = Ogone.run['data-o3sab'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-o3sab-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-o3sab-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-z3yrn-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-z3yrn']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'router';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-z3yrn'] = Ogone.run['data-z3yrn'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            routes: [{ "path": "/doc", "name": "documentation", "component": "data-xxnzv-nt", "title": "Ogone - documentation" }, { "path": "/todos/:id", "component": "data-o3sab-nt", "name": "todo" }, { "path": 404, "name": 404, "component": "data-o3sab-nt", "title": "404 route not found" }],
            // set the location
            locationPath: location.pathname,
            // set the actualTemplate of the router
            actualTemplate: null,
            // save the route
            actualRoute: null,
            actualRouteName: null,
            // whenever the route change
            routeChanged: true,
            // set state to pass it through the history.state
            historyState: { ...(() => {
                    const url = new URL(location.href);
                    const query = new Map(url.searchParams.entries());
                    return { query };
                })(), },
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle() { }
    // use bindClass method
    // this method allow --class flag
    bindClass() { }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() {
        const o = this.ogone;
        const oc = o.component;
        const rr = Ogone.router.react;
        oc.runtime(0, o.historyState);
        rr.push((path) => {
            o.locationPath = path;
            this.setActualRouterTemplate();
            this.renderRouter();
            return oc.activated;
        });
    }
    routerSearch(route, locationPath) {
        if (typeof locationPath !== 'string')
            return false;
        const { path } = route;
        const splitted = path.toString().split('/');
        const locationSplit = locationPath.split('/');
        const result = {};
        if (!splitted.filter(r => r.trim().length).length !== !locationSplit.filter(r => r.trim().length).length)
            return;
        if (splitted.length !== locationSplit.length)
            return false;
        const error = splitted.find((p, i, arr) => {
            if (!p.startsWith(':')) {
                return locationSplit[i] !== p;
            }
        });
        if (error)
            return false;
        splitted.forEach((p, i, arr) => {
            if (p.startsWith(':')) {
                const param = p.slice(1, p.length);
                arr[i] = null;
                result[param] = locationSplit[i];
            }
        });
        route.params = result;
        return true;
    }
    setActualRouterTemplate() {
        const o = this.ogone;
        const oc = o.component;
        oc.routes = o.routes;
        oc.locationPath = o.locationPath;
        const l = oc.locationPath;
        let rendered = oc.routes.find((r) => r.path === l || this.routerSearch(r, l) || r.path === 404);
        let preservedParams = rendered.params;
        // redirections
        while (rendered && rendered.redirect) {
            rendered = oc.routes.find((r) => r.name === rendered.redirect);
            if (rendered) {
                rendered.params = preservedParams;
            }
        }
        if (!rendered) {
            o.actualTemplate = [new Comment()];
            o.actualRoute = null;
            o.routeChanged = true;
        }
        else if (rendered && !(rendered.once || o.actualRoute === rendered.component)) {
            const { component: uuidC } = rendered;
            const co = document.createElement('template', { is: uuidC });
            o.actualTemplate = [co];
            o.actualRoute = rendered.component;
            o.actualRouteName = rendered.name || null;
            o.routeChanged = true;
            // don't spread o
            // some props of o can overwritte the template.ogone and create errors in context
            // like undefined data
            co.setOgone({
                params: rendered.params || null,
                props: o.props,
                parentComponent: o.parentComponent,
                parentCTXId: o.parentCTXId,
                positionInParentComponent: o.positionInParentComponent
                    .slice(),
                levelInParentComponent: o.levelInParentComponent,
                index: o.index,
                level: o.level,
                position: o.position,
                flags: o.flags,
            });
            // if the route provide any title
            // we change the title of the document
            if (rendered.title) {
                document.title = rendered.title;
            }
        }
        else {
            o.routeChanged = false;
        }
    }
    renderRouter() {
        const o = this.ogone;
        const oc = o.component;
        // update Props before replacement of the element
        oc.updateProps();
        // we will use o.replacer cause it's used in the flag if
        if (!o.actualTemplate) {
            o.actualTemplate = o.replacer;
        }
        if (this.parentNode) {
            this.replaceWith(...o.actualTemplate);
            o.replacer = o.actualTemplate;
        }
        else if (o.routeChanged) {
            const replacer = o.replacer && o.replacer[0].ogone ?
                [[o.replacer[0].context.placeholder], o.replacer[0].ogone.nodes].find(n => n[0] && n[0].isConnected)
                : o.replacer;
            if (!replacer)
                return;
            replacer.slice(1, replacer.length).forEach(n => n.remove());
            for (let n of replacer) {
                n.isConnected ? n.replaceWith(...o.actualTemplate) : '';
            }
            o.replacer[0] && o.replacer[0].isComponent ? o.replacer[0].destroy() : 0;
        }
        o.replacer = o.actualTemplate;
        oc.runtime(o.actualRouteName || o.locationPath, history.state);
    }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-z3yrn-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        this.setActualRouterTemplate();
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.renderRouter();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
        this.triggerLoad();
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-z3yrn-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-x33ao-nd7'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd7' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-x33ao-nd7';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-x33ao-nd7'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-x33ao-nd5'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd5' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-x33ao-nd5';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-x33ao-nd5'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-x33ao-nd3'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd3' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-x33ao-nd3';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-x33ao-nd3'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-x33ao-nd2'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = (["item"]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd2' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-x33ao-nd2';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-x33ao-nd2'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-x33ao-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-x33ao']();
        component.requirements = ([["item", ["Object"]]]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-x33ao'] = Ogone.run['data-x33ao'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-x33ao-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-x33ao-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-35zxv-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-35zxv']();
        component.requirements = (null);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'store';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-35zxv'] = Ogone.run['data-35zxv'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle() { }
    // use bindClass method
    // this method allow --class flag
    bindClass() { }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() {
        const o = this.ogone;
        const oc = o.component;
        if (oc.namespace !== 'menu') {
            const error = 'the attribute namespace is not the same provided in the component store';
            const BadNamspaceException = new Error(`[Ogone] ${error}`);
            Ogone.error(error, 'Store Module: Bad Namsepace Exception', {
                message: `
            store namespace: menu
            attribute namespace: ${oc.namespace}
            `
            });
            throw BadNamspaceException;
        }
        oc.startLifecycle();
        this.removeNodes().remove();
    }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-35zxv-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.renderStore();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-35zxv-nt'].bind(o.component.data);
        }
        oc.namespace = this.getAttribute('namespace') || null;
        oc.parent.store[oc.namespace] = oc;
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-yoanx-nd5'] = class extends HTMLElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = null;
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            // int, position[level] = index
            // define component
            // get from router the parameters
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nd5' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return this.tagName.toLowerCase();
    }
    get extends() {
        return 'data-yoanx-nd5';
    }
    get isComponent() {
        return false;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            component: this.ogone.component,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-yoanx-nd5'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = [o.render(o.component, o.position, o.index, o.level)];
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.render(this, {
            callingNewComponent: false,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (false) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-yoanx-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-yoanx']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-yoanx'] = Ogone.run['data-yoanx'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-yoanx-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-yoanx-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-5zxav-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-5zxav']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-5zxav'] = Ogone.run['data-5zxav'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-5zxav-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-5zxav-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-3vbxo-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-3vbxo']();
        component.requirements = (null);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-3vbxo'] = Ogone.run['data-3vbxo'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-3vbxo-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-3vbxo-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-oyzy5-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-oyzy5']();
        component.requirements = ([["test", ["Number"]]]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-oyzy5'] = Ogone.run['data-oyzy5'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-oyzy5-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-oyzy5-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-5b3rz-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-5b3rz']();
        component.requirements = ([["title", ["String"]], ["text", ["String"]], ["code", ["String"]]]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-5b3rz'] = Ogone.run['data-5b3rz'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-5b3rz-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-5b3rz-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-xxnzv-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-xxnzv']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-xxnzv'] = Ogone.run['data-xxnzv'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-xxnzv-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-xxnzv-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
Ogone.classes['data-555ax-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-555ax']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        Ogone.run['data-555ax'] = Ogone.run['data-555ax'] || [];
        // define templates of hmr
        Ogone.mod[this.extends] = Ogone.mod[this.extends] || [];
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone;
        const oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone;
        const oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone;
        const oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-555ax-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            oc.key = o.key;
            oc.dependencies = o.dependencies;
            if (o.parentComponent) {
                oc.parent = o.parentComponent;
                oc.parent.childs.push(oc);
            }
            if (Ogone.contexts[o.parentCTXId]) {
                const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
                oc.parentContext = gct;
                o.getContext = gct;
            }
        }
        else {
            o.getContext = Ogone.contexts['data-555ax-nt'].bind(o.component.data);
        }
    }
    setHMRContext() {
        const o = this.ogone;
        const oc = o.component;
        // register to hmr
        Ogone.run['${component.uuid}'].push(oc);
        Ogone.mod[this.extends].push((pragma) => {
            Ogone.render[this.extends] = eval(pragma);
            o.render = Ogone.render[this.extends];
            const invalidatedNodes = o.nodes.slice();
            this.renderingProcess();
            invalidatedNodes.forEach((n, i) => {
                if (n.ogone) {
                    if (i === 0)
                        n.firstNode.replaceWith(...o.nodes);
                    n.destroy();
                }
                else {
                    if (i === 0)
                        n.replaceWith(...o.nodes);
                    n.remove();
                }
            });
            oc.renderTexts(true);
            return true;
        });
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone;
        const oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone;
        const oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
customElements.define('data-555ax-nt', Ogone.classes['data-555ax-nt'], { extends: 'template' });
customElements.define('data-xxnzv-nt', Ogone.classes['data-xxnzv-nt'], { extends: 'template' });
customElements.define('data-5b3rz-nt', Ogone.classes['data-5b3rz-nt'], { extends: 'template' });
customElements.define('data-oyzy5-nt', Ogone.classes['data-oyzy5-nt'], { extends: 'template' });
customElements.define('data-3vbxo-nt', Ogone.classes['data-3vbxo-nt'], { extends: 'template' });
customElements.define('data-5zxav-nt', Ogone.classes['data-5zxav-nt'], { extends: 'template' });
customElements.define('data-yoanx-nt', Ogone.classes['data-yoanx-nt'], { extends: 'template' });
customElements.define('data-yoanx-nd5', Ogone.classes['data-yoanx-nd5']);
customElements.define('data-35zxv-nt', Ogone.classes['data-35zxv-nt'], { extends: 'template' });
customElements.define('data-x33ao-nt', Ogone.classes['data-x33ao-nt'], { extends: 'template' });
customElements.define('data-x33ao-nd2', Ogone.classes['data-x33ao-nd2']);
customElements.define('data-x33ao-nd3', Ogone.classes['data-x33ao-nd3']);
customElements.define('data-x33ao-nd5', Ogone.classes['data-x33ao-nd5']);
customElements.define('data-x33ao-nd7', Ogone.classes['data-x33ao-nd7']);
customElements.define('data-z3yrn-nt', Ogone.classes['data-z3yrn-nt'], { extends: 'template' });
customElements.define('data-o3sab-nt', Ogone.classes['data-o3sab-nt'], { extends: 'template' });
customElements.define('data-s3sox-nt', Ogone.classes['data-s3sox-nt'], { extends: 'template' });
customElements.define('data-s3sox-nd5', Ogone.classes['data-s3sox-nd5']);
customElements.define('data-s3sox-nd17', Ogone.classes['data-s3sox-nd17']);
customElements.define('data-avsnr-nt', Ogone.classes['data-avsnr-nt'], { extends: 'template' });
customElements.define('data-avsnr-nd5', Ogone.classes['data-avsnr-nd5']);
customElements.define('data-avsnr-nd8', Ogone.classes['data-avsnr-nd8']);
customElements.define('data-avsnr-nd10', Ogone.classes['data-avsnr-nd10']);
customElements.define('data-avsnr-nd12', Ogone.classes['data-avsnr-nd12']);
customElements.define('data-avsnr-nd15', Ogone.classes['data-avsnr-nd15']);
customElements.define('data-xsano-nt', Ogone.classes['data-xsano-nt'], { extends: 'template' });
customElements.define('data-zbnay-nt', Ogone.classes['data-zbnay-nt'], { extends: 'template' });
          </script>
  </head>
  <body>
      <template is="data-555ax-nt"></template>;
  </body>
</html>
