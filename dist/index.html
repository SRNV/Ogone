
<html>
  <head>
      
          <style></style>
          
  <link href="/public/style.css" rel="stylesheet"/>
  <link href="/public/animations.css" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.2/styles/night-owl.min.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto|Varela+Round" rel="stylesheet"></link>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.9.1/showdown.min.js"></script>
  
          <script>
            function OComponent() {
    this.key = null;
    this.data = null;
    this.dependencies = null;
    this.state = 0;
    this.activated = true;
    this.namespace = null;
    this.store = {};
    this.contexts = {
        for: {},
    };
    // for async context
    this.promises = [];
    this.resolve = null;
    this.async = {
        then: null,
        catch: null,
        finally: null,
    };
    this.dispatchAwait = null;
    this.promiseResolved = false;
    // events describers
    // this.events = {};
    // all nodes that's are dynamics will save a function into this property
    // like if we have
    //  <node --for="array as (el, i)" />
    // this node will register a function() { ... } that will be triggered each time there is an update
    //this.rerenderAsync = null;
    this.react = [];
    this.texts = [];
    this.childs = [];
    this.startLifecycle = (params, event) => {
        if (!this.activated)
            return;
        if (this.type === "store") {
            this.initStore();
        }
        // WIP
        Object.seal(this.data);
        this.runtime(0, params, event);
        this.state = 1; // component is rendered
    };
    this.update = (dependency) => {
        if (!this.activated)
            return;
        if (this.type === "store") {
            this.updateStore(dependency);
            return;
        }
        this.runtime(`update:${dependency}`);
        this.reactTo(dependency);
        this.renderTexts(dependency);
        this.childs.filter((c) => c.type !== "store").forEach((c) => {
            c.updateProps(dependency);
        });
    };
    this.renderTexts = (dependency) => {
        if (!this.activated)
            return;
        this.texts.forEach((t, i, arr) => {
            // if there is no update of the texts
            // this can be the reason why
            if (t && !t(dependency))
                delete arr[i];
        });
    };
    this.reactTo = (dependency) => {
        if (!this.activated)
            return;
        this.react.forEach((t, i, arr) => {
            if (t && !t(dependency))
                delete arr[i];
        });
    };
    this.initStore = () => {
        if (!Ogone.stores[this.namespace]) {
            Ogone.stores[this.namespace] = {
                ...this.data,
            };
        }
        // save the component's reaction into Ogone.clients with the key of the component
        // and a function
        Ogone.clients.push([this.key, (namespace, key, overwrite) => {
                if (namespace === this.namespace &&
                    this.data &&
                    this.parent &&
                    this.parent.data &&
                    key in this.parent.data) {
                    if (!overwrite) {
                        this.data[key] = Ogone.stores[this.namespace][key];
                    }
                    else {
                        Ogone.stores[this.namespace][key] = this.data[key];
                    }
                    this.parent.data[key] = this.data[key];
                    this.parent.update(key);
                }
                return true;
            }]);
    };
    this.updateStore = (dependency) => {
        // find the reaction of this store module with the key
        // @ts-ignore
        const [key, client] = Ogone.clients.find(([key]) => key === this.key);
        if (client) {
            // use the namespace, the dependency or property that should change
            // @ts-ignore
            client(this.namespace, dependency, true);
            // update other modules
            Ogone.clients.filter(([key]) => key !== this.key).forEach(([key, f], i, arr) => {
                if (f && !f(this.namespace, dependency, false)) {
                    delete arr[i];
                }
            });
        }
    };
    this.updateProps = (dependency) => {
        if (!this.activated)
            return;
        if (this.type === "store")
            return;
        if (!this.requirements || !this.props)
            return;
        this.requirements.forEach(([key, constructors]) => {
            const prop = this.props.find((prop) => prop[0] === key);
            const isAny = constructors.includes(null);
            if (!prop && !isAny) {
                const UndefinedPropertyForComponentException = `${key} is required as property but still undefined. Please use this syntax\n\t\t<component :${key}="..."></component>`;
                const err = new Error("[Ogone]  " + UndefinedPropertyForComponentException);
                Ogone.error(UndefinedPropertyForComponentException, `Undefined property ${key}. But ${key} is required in component`, err);
                throw err;
            }
            if (!prop)
                return;
            const value = this.parentContext({
                getText: `${prop[1]}`,
                position: this.positionInParentComponent,
            });
            if ((value === undefined || value === null) && !isAny) {
                const message = `${key} is required as property but can\'t be null. Please use this syntax\n\t\t<component :${key}="${constructors.join(" | ")}"></component>`;
                const NullishPropertyException = new Error("[Ogone]  " + message);
                Ogone.error(message, `Property ${key} can't be null for the component`, NullishPropertyException);
                throw NullishPropertyException;
            }
            if (!constructors.includes(value.constructor.name)) {
                const message = `${key} is required as property but it's value is not one of ${constructors.join(" | ")}
            evaluated value: ${prop[1]}
            constructor: ${value.constructor.name}`;
                const PropertyDontMatchWithConstructorsException = new Error("[Ogone] " + message);
                Ogone.error(message, `TypeError for property ${key}`, PropertyDontMatchWithConstructorsException);
                throw PropertyDontMatchWithConstructorsException;
            }
            if (this.data && value !== this.data[key]) {
                this.data[key] = value;
                this.update(key);
                if (this.type === "async") {
                    if (!this.dependencies)
                        return;
                    if (dependency &&
                        this.dependencies.find((d) => d.indexOf(dependency) > -1)) {
                        // let the user rerender
                        this.runtime("async:update", {
                            updatedParentProp: dependency,
                        });
                    }
                }
            }
        });
    };
    this.render = (Onode, /** original node */ opts) => {
        if (!Onode || !opts)
            return;
        // Onode is a web component
        // based on the user token
        // this web component is a custom Element
        // not an extension of an element cause the attr "is" is not dynamic
        // at the first call of this function Onode is not "rendered" (replaced by the required element)
        let { callingNewComponent, length: dataLength } = opts;
        typeof dataLength === "object" ? dataLength = 1 : [];
        const context = Onode.context;
        // no need to render if it's the same
        if (context.list.length === dataLength)
            return;
        let previousTemplate;
        // first we add missing nodes, we use cloneNode to generate the web-component
        for (let i = context.list.length, a = dataLength; i < a; i++) {
            let node;
            // @ts-ignore
            node = document.createElement(context.name, { is: Onode.extends });
            node.setOgone({
                index: i,
                originalNode: false,
                level: Onode.ogone.level,
                position: Onode.ogone.position.slice(),
                flags: Onode.ogone.flags,
                orinal: Onode,
                ...(!callingNewComponent ? { component: this } : {
                    props: Onode.ogone.props,
                    params: Onode.ogone.params,
                    parentComponent: Onode.ogone.parentComponent,
                    parentCTXId: Onode.ogone.parentCTXId,
                    positionInParentComponent: Onode.ogone.positionInParentComponent
                        .slice(),
                    levelInParentComponent: Onode.ogone.levelInParentComponent,
                }),
            });
            if (i === 0) {
                context.placeholder.replaceWith(node);
            }
            else {
                let lastEl = context.list[i - 1];
                if (lastEl && lastEl.isConnected) {
                    lastEl.insertElement("afterend", node);
                }
                else if (Onode && Onode.parentNode) {
                    Onode.parentNode.insertBefore(node, Onode.nextElementSibling);
                }
            }
            context.list.push(node);
            previousTemplate = node;
        }
        // no need to remove if it's the same
        if (context.list.length === dataLength)
            return;
        // now we remove the extra elements
        for (let i = context.list.length, a = dataLength; i > a; i--) {
            if (context.list.length === 1) {
                // get the first element of the webcomponent
                let firstEl = context.list[0];
                if (firstEl && firstEl.firstNode && firstEl.isConnected) {
                    firstEl.insertElement("beforebegin", context.placeholder);
                }
                else if (Onode.parentNode) {
                    const { parentNode } = context;
                    parentNode.insertBefore(context.placeholder, Onode);
                }
            }
            const rm = context.list.pop();
            // deactivate all the reactions of the component
            rm.removeNodes().remove();
        }
    };
    return this;
}
// @ts-ignore
const Ogone = {
    // store
    stores: {},
    clients: [],
    render: {},
    contexts: {},
    components: {},
    classes: {},
    errorPanel: null,
    warnPanel: null,
    successPanel: null,
    infosPanel: null,
    historyError: null,
    errors: 0,
    firstErrorPerf: null,
    sound: null,
    oscillator: null,
    error(message, errorType, errorObject) {
        // here we render the errors in development
        if (!this.errorPanel) {
            const p = document.createElement("div");
            const h = document.createElement("div");
            Object.entries({
                zIndex: "5000000",
                background: "#00000097",
                width: "100vw",
                height: "100vh",
                position: "fixed",
                overflowY: "auto",
                justifyContent: "center",
                display: "grid",
                flexDirection: "column",
            }).forEach(([key, value]) => p.style[key] = value);
            h.style.width = "100vw";
            h.style.position = "fixed";
            h.style.background = "black";
            h.style.bottom = "26px";
            h.style.height = "20px";
            h.style.left = "0px";
            h.style.zIndex = "50000000";
            this.errorPanel = p;
            this.errorPanel.append(h);
            this.historyError = h;
        }
        this.errors++;
        const err = document.createElement("div");
        Object.entries({
            zIndex: "5000000",
            background: "#000000",
            minHeight: "fit-content",
            maxWidth: "70%",
            padding: "21px",
            color: "red",
            borderLeft: "3px solid red",
            margin: "auto",
            display: "inline-flex",
            flexDirection: "column",
        }).forEach(([key, value]) => err.style[key] = value);
        const errorId = this.errors;
        const code = document.createElement("code");
        const stack = document.createElement("code");
        const h = document.createElement("h4");
        const errorPin = document.createElement("div");
        // set the text
        h.innerText = `[Ogone] Error ${errorId}: ${errorType ||
            "Undefined Type"}`;
        code.innerText = `${message.trim()}`;
        stack.innerText = `${
        // @ts-ignore
        errorObject && errorObject.stack
            ? // @ts-ignore
                errorObject.stack.replace(message, "")
            : ""}`;
        // check if stack is empty or not
        if (!stack.innerText.length && errorObject && errorObject.message) {
            stack.innerText = `${errorObject && errorObject.message ? errorObject.message : ""}`;
        }
        !stack.innerText.length ? stack.innerText = "undefined stack" : "";
        // set the styles
        code.style.marginLeft = "20px";
        code.style.whiteSpace = "pre-wrap";
        code.style.wordBreak = "break-word";
        stack.style.marginLeft = "20px";
        stack.style.color = "#dc7373";
        stack.style.padding = "17px";
        stack.style.background = "#462626";
        stack.style.whiteSpace = "pre-wrap";
        stack.style.wordBreak = "break-word";
        stack.style.border = "1px solid";
        stack.style.marginTop = "10px";
        h.style.color = "#8c8c8c";
        errorPin.style.background = "red";
        errorPin.style.width = "13px";
        errorPin.style.height = errorPin.style.width;
        errorPin.style.position = "fixed";
        errorPin.style.bottom = "30px";
        errorPin.style.zIndex = "50000000";
        const relativePinPosition = Math.round((this.firstErrorPerf / performance.now()) * 30) + 30;
        errorPin.style.left = this.firstErrorPerf
            ? `${relativePinPosition}px`
            : "30px";
        if (!this.firstErrorPerf) {
            this.firstErrorPerf = performance.now();
        }
        this.errorPanel.style.paddingTop = "30px";
        // set the grid of errors
        err.style.gridArea = `e${errorId}`;
        const m = 2;
        let grid = "";
        let i = 0;
        let a = 0;
        for (i = 0, a = this.errorPanel.childNodes.length + 1; i < a; i++) {
            grid += `e${i + 1} `;
        }
        let b = i;
        while (i % m) {
            grid += `e${b} `;
            i++;
        }
        const cells = grid.split(" ");
        var o, j, temparray, chunk = m;
        let newgrid = "";
        for (o = 0, j = cells.length - 1; o < j; o += chunk) {
            temparray = cells.slice(o, o + chunk);
            newgrid += ` "${temparray.join(" ")}"`;
        }
        this.errorPanel.style.gridGap = "10px";
        this.errorPanel.style.gridAutoRows = "max-content";
        this.errorPanel.style.gridTemplateAreas = newgrid;
        err.style.animationName = "popup";
        err.style.animationIterationCoutn = "1";
        err.style.animationDuration = "0.5s";
        // append elements
        err.append(h, code, stack);
        this.errorPanel.append(err);
        this.errorPanel.append(errorPin);
        this.errorPanel.style.pointerEvents = "scroll";
        //  append only if it's not in the document
        !this.errorPanel.isConnected
            ? document.body.append(this.errorPanel)
            : [];
    },
};
Ogone.router = {
    react: [],
    actualRoute: null,
    go: (url, state) => {
        if (!Ogone.router)
            return;
        if (Ogone.router.actualRoute === url)
            return;
        // protect from infinite loop
        Ogone.router.actualRoute = url;
        Ogone.router.react.forEach((r, i, arr) => {
            if (r && !r(url, state))
                delete arr[i];
        });
        // @ts-ignore
        history.pushState(state || {}, "", url || "/");
    },
};
// @ts-ignore
window.onpopstate = function (event) {
    // @ts-ignore
    Ogone.router.go(location.pathname, event.state);
};
Ogone.components['data-r35yo'] = function () {
    OComponent.call(this);
    const ____ = (prop, inst) => {
        this.update(prop);
    };
    const ____r = (name, use, once) => {
        this.runtime(name, use[0], use[1], once);
    };
    this.data = { "name": null };
    this.refs = {};
    const Refs = this.refs;
    let random = Ogone.mod['/examples/modules/module.js'].default;
    Ogone.mod['*'].push(['/examples/modules/module.js', (m) => {
            if (!this.activated)
                return false;
            random = m.default;
            this.runtime('destroy');
            this.runtime(0);
            return this.activated;
        }]);
    let test = Ogone.mod['/examples/modules/allAS.js'];
    Ogone.mod['*'].push(['/examples/modules/allAS.js', (m) => {
            if (!this.activated)
                return false;
            test = m;
            this.runtime('destroy');
            this.runtime(0);
            return this.activated;
        }]);
    let defaulto = Ogone.mod['/examples/modules/allAS.js'].default;
    Ogone.mod['*'].push(['/examples/modules/allAS.js', (m) => {
            if (!this.activated)
                return false;
            defaulto = m.default;
            this.runtime('destroy');
            this.runtime(0);
            return this.activated;
        }]);
    let lol = Ogone.mod['/examples/modules/allAS.js'].lol;
    Ogone.mod['*'].push(['/examples/modules/allAS.js', (m) => {
            if (!this.activated)
                return false;
            lol = m.lol;
            this.runtime('destroy');
            this.runtime(0);
            return this.activated;
        }]);
    let instance = Ogone.mod['/examples/modules/allAS.js'].instance;
    Ogone.mod['*'].push(['/examples/modules/allAS.js', (m) => {
            if (!this.activated)
                return false;
            instance = m.instance;
            this.runtime('destroy');
            this.runtime(0);
            return this.activated;
        }]);
    const __run = (function (_state, ctx, event, _once = 0) {
        try {
            if (typeof _state === "string" && ![].includes(_state)) {
                return;
            }
            switch (_state) {
                default:
                    this.name = random;
                    ____('name', this);
                    console.warn(test, defaulto, instance, lol);
            }
        }
        catch (err) {
            Ogone.error('Error in the component: \n\t examples/tests/modules/index.o3', err.message, err);
            throw err;
        }
    });
    this.runtime = (__run || function () { }).bind(this.data);
};
Ogone.render['data-r35yo-nt'] = (function (ctx, position = [], index = 0, level = 0) { const nt = document.createElement('null'); if (position)
    position[level] = index; nt.setAttribute('data-r35yo', ''); nt.append(``, (function (ctx, position = [], index = 0, level = 0) { const n4 = document.createElement('p'); if (position)
    position[level] = index; n4.setAttribute('data-r35yo', ''); n4.append((function (ctx, position = [], index = 0, level = 0) { const t11 = new Text(' '); const g = Ogone.contexts['data-r35yo-t11'].bind(ctx.data); /* getContext function */ /* getContext function */ const txt = '`user ${name}`'; function r(key) { if (key instanceof String && txt.indexOf(key) < 0)
    return true; const v = g({ getText: txt, position, }); if (t11.data && t11.data !== v)
    t11.data = v; return true; } ; ctx.texts.push(r); return t11; })(ctx, position.slice())); return n4; })(ctx, position.slice(), index, level + 1)); return nt; });
Ogone.contexts['data-r35yo-nt'] = function (opts) {
    const GET_TEXT = opts.getText;
    const GET_LENGTH = opts.getLength;
    const POSITION = opts.position;
    const name = this.name;
    let random = Ogone.mod['/examples/modules/module.js'].default;
    ;
    let test = Ogone.mod['/examples/modules/allAS.js'];
    ;
    let defaulto = Ogone.mod['/examples/modules/allAS.js'].default;
    ;
    let lol = Ogone.mod['/examples/modules/allAS.js'].lol;
    if (GET_TEXT) {
        try {
            return eval('(' + GET_TEXT + ')');
        }
        catch (err) {
            Ogone.error('Error in component:\n\t examples/tests/modules/index.o3 ' + `${GET_TEXT}`, err.message, err);
            throw err;
        }
    }
    return { name };
};
Ogone.contexts['data-r35yo-n4'] = Ogone.contexts['data-r35yo-nt'];
Ogone.contexts['data-r35yo-t11'] = Ogone.contexts['data-r35yo-n4'];
Ogone.contexts['data-r35yo-t3'] = Ogone.contexts['data-r35yo-nt'];
Ogone.classes['data-r35yo-nt'] = class extends HTMLTemplateElement {
    constructor() {
        super();
        this.dependencies = ([]);
        this.positionInParentComponent = [];
        const component = new Ogone.components['data-r35yo']();
        component.requirements = ([]);
        component.dependencies = ([]);
        this.component = component;
        this.component.type = 'component';
        this.setOgone();
        // define runtime for hmr
        // define templates of hmr
    }
    // set the modifier object for Ogone fe atures
    setOgone(def = {}) {
        this.ogone = {
            // int[]
            position: [0],
            // int[]
            positionInParentComponent: [0],
            // int
            levelInParentComponent: 0,
            // int
            index: 0,
            // int, position[level] = index
            level: 0,
            // define component
            component: this.component,
            // get from router the parameters
            params: null,
            // define parentComponent
            parentComponent: null,
            // jsx function
            render: null,
            // register all nodes of template or custom element
            nodes: [],
            // {}[]
            flags: null,
            // replacer is used for --ifElse flag
            replacer: null,
            // critical function
            getContext: null,
            // set as false by the component, preserves from maximum call stack
            originalNode: true,
            // promise for await flag
            promise: null,
            dependencies: [],
            // set unique key
            key: 'nt' + `${Math.random()}`,
            // set routes if component is a router
            // set the location
            // set the actualTemplate of the router
            // save the route
            // whenever the route change
            // set state to pass it through the history.state
            // overwrite properties
            ...def,
        };
        // use the jsx function and save it into this.ogone.render
        // this function generates all the childNodes or the template
        this.ogone.render = Ogone.render[this.extends];
    }
    // use bindStyle method
    // this method allow --style flag
    bindStyle(value) {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.style)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: o.flags.style,
            });
            if (typeof vl === 'string') {
                n.style = vl;
            }
            else if (typeof vl === 'object') {
                Object.entries(vl).forEach(([k, v]) => n.style[k] = v);
            }
            return n.isConnected;
        }
        for (let n of o.nodes) {
            oc.react.push(() => r(n));
            r(n);
        }
    }
    // use bindClass method
    // this method allow --class flag
    bindClass() {
        const o = this.ogone, oc = o.component;
        if (!o.flags || !o.flags.class)
            return;
        function r(n) {
            const vl = o.getContext({
                position: o.position,
                getText: (o.flags.class),
            });
            if (typeof vl === 'string') {
                n.classList.value = vl;
            }
            else if (typeof vl === 'object') {
                const keys = Object.keys(vl);
                n.classList.add(...keys.filter((key) => vl[key]));
                n.classList.remove(...keys.filter((key) => !vl[key]));
            }
            else if (Array.isArray(vl)) {
                n.classList.value = vl.join(' ');
            }
            return n.isConnected;
        }
        for (let node of o.nodes) {
            oc.react.push(() => r(node));
            r(node);
        }
    }
    // set events on the node
    // this method allow all DOM level 3 events
    setEvents() {
        if (!this.ogone.flags)
            return;
        const o = this.ogone, oc = o.component;
        const position = this.isComponent ? oc.positionInParentComponent : o.position;
        const c = this.isComponent ? oc.parent : oc;
        for (let node of o.nodes) {
            for (let flag of o.flags.events) {
                if (flag.type === 'wheel') /* for wheel events */ {
                    node.hasWheel = true;
                    node.addEventListener(flag.type, (ev) => {
                        const foundWheel = ev.path.find(n => n && n.hasWheel);
                        if (foundWheel && !foundWheel.isSameNode(node))
                            return;
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case filter === 'right' && ev.wheelDeltaX < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'left' && ev.wheelDeltaX > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'up' && ev.wheelDeltaY > 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === 'down' && ev.wheelDeltaY < 0:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case filter === null:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.type.startsWith("key")) /* all keyboard event */ {
                    document.addEventListener(flag.type, (ev) => {
                        const filter = o.getContext({
                            getText: `${flag.filter}`,
                            position,
                        });
                        const ctx = o.getContext({
                            position,
                        });
                        switch (true) {
                            case ev.charCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.key === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.keyCode === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case ev.code.toLowerCase() === filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                            case !filter:
                                c.runtime(flag.case, ctx, ev);
                                break;
                        }
                    });
                }
                else if (flag.name === 'router-go' && flag.eval) /* special for router-go flag */ {
                    node.addEventListener("click", (ev) => {
                        Ogone.router.go(o.getContext({
                            getText: `${flag.eval}`,
                            position,
                        }), history.state);
                    });
                }
                else /* DOM L3 */ {
                    node.addEventListener(flag.type, (ev) => {
                        const ctx = o.getContext({
                            position,
                        });
                        c.runtime(flag.case, ctx, ev);
                    });
                }
            }
        }
    }
    // methods for routers components
    triggerLoad() { }
    routerSearch() { }
    setActualRouterTemplate() { }
    renderRouter() { }
    // methods for stores components
    renderStore() { }
    // methods for all components
    // this allow the use of <slot> tag
    renderSlots() {
        const o = this.ogone;
        const slots = this.querySelectorAll('[slot]');
        for (let node of o.nodes.filter(n => n.nodeType === 1)) {
            // d for default slots
            const d = node.querySelector('slot:not([name])');
            if (d) {
                d.replaceWith(...this.childNodes);
            }
        }
        for (let slotted of slots) {
            // sn for slotName
            const sn = slotted.getAttribute('slot');
            for (let n of o.nodes) {
                const s = n.querySelector(`slot[name="${sn}"]`);
                if (s) {
                    slotted.removeAttribute('slot');
                    s.replaceWith(slotted);
                }
            }
        }
    }
    // methods for async components
    // global methods for components
    // mainly getters and setters
    get context() {
        const o = this.ogone, oc = o.component;
        if (!oc.contexts.for[o.key]) {
            oc.contexts.for[o.key] = {
                list: [this],
                placeholder: document.createElement('template'),
                parentNode: this.parentNode,
                name: this.name,
            };
        }
        return oc.contexts.for[o.key];
    }
    insertElement(p, el) {
        if (!this.firstNode) {
            this.insertAdjacentElement(p, el);
            return;
        }
        let target;
        switch (p) {
            case 'beforebegin':
                target = this.firstNode;
                break;
            case 'afterbegin':
                target = this.firstNode;
                break;
            case 'beforeend':
                target = this.lastNode;
                break;
            case 'afterend':
                target = this.lastNode;
                break;
        }
        return (!!target.ogone ?
            (target.context.list[target.context.list.length - 1]).insertElement(p, el) :
            target.insertAdjacentElement(p, el));
    }
    get isConnected() {
        if (!this.firstNode) {
            return false;
        }
        return !!this.ogone.nodes.find((n) => n.isConnected);
    }
    get isRecursiveConnected() {
        return this.firstNode.isConnected && this.lastNode.isConnected;
    }
    get firstNode() {
        return this.ogone.nodes[0];
    }
    get lastNode() {
        const o = this.ogone.nodes;
        return o[o.length - 1];
    }
    get name() {
        return "template";
    }
    get extends() {
        return 'data-r35yo-nt';
    }
    get isComponent() {
        return true;
    }
    get clone() {
        const node = document.createElement(this.name, { is: this.extends });
        node.setOgone({
            index: this.ogone.index,
            originalNode: true,
            level: this.ogone.level,
            position: this.ogone.position,
            flags: this.ogone.flags,
            dependencies: this.ogone.dependencies,
            render: this.ogone.render,
            props: this.ogone.props,
            params: this.ogone.params,
            parentComponent: this.ogone.parentComponent,
            parentCTXId: this.ogone.parentCTXId,
            positionInParentComponent: this.ogone.positionInParentComponent
                .slice(),
            levelInParentComponent: this.ogone.levelInParentComponent,
        });
        return node;
    }
    // setContext and setHMRContext
    setContext() {
        const o = this.ogone;
        const oc = o.component;
        oc.key = o.key;
        oc.dependencies = o.dependencies;
        if (o.parentComponent) {
            oc.parent = o.parentComponent;
            oc.parent.childs.push(oc);
        }
        if (Ogone.contexts[o.parentCTXId]) {
            const gct = Ogone.contexts[o.parentCTXId].bind(o.parentComponent.data);
            oc.parentContext = gct;
            o.getContext = gct;
        }
    }
    connectedCallback(rendered) {
        // set position of the template/component
        this.setPosition();
        // set the context of the node
        this.setContext();
        // parse the route that match with location.pathname
        // set the props required by the node
        this.setProps();
        this.ogone.component.updateProps();
        this.renderingProcess();
        // now ... just render ftw!
        this.render();
    }
    renderingProcess() {
        // use the jsx renderer only for templates
        this.setNodes();
        // set Async context for Async nodes
        // use the previous jsx and push the result into ogone.nodes
        // set the dependencies of the node into the component
        this.setDeps();
        // set the events
        this.setEvents();
        // bind classList
        this.bindClass();
        // bind style
        this.bindStyle();
        // set history state and trigger default code for router
    }
    setPosition() {
        this.ogone.position[this.ogone.level] = this.ogone.index;
    }
    setProps() {
        const o = this.ogone;
        if (!o.index) {
            o.index = 0;
        }
        o.component.props = o.props;
        o.component.positionInParentComponent = o.positionInParentComponent;
        o.positionInParentComponent[o.levelInParentComponent] = o.index;
        o.component.updateProps();
    }
    setNodes() {
        const o = this.ogone;
        o.nodes = Array.from(o.render(o.component).childNodes);
    }
    setDeps() {
        const o = this.ogone;
        if (o.originalNode && o.getContext) {
            o.component.parent.react.push(() => this.renderContext());
            this.renderContext();
        }
    }
    renderContext() {
        const o = this.ogone, oc = o.component;
        const key = o.key;
        const length = o.getContext({ getLength: true, position: o.position });
        o.component.parent.render(this, {
            callingNewComponent: true,
            key,
            length,
        });
        return true;
    }
    removeNodes() {
        /* use it before removing template node */
        if (this.ogone.actualTemplate) {
            this.ogone.actualTemplate.forEach((n) => {
                if (n.ogone) {
                    n.destroy();
                }
                else {
                    n.remove();
                }
            });
        }
        this.ogone.nodes.forEach((n) => {
            if (n.ogone) {
                n.destroy();
            }
            else {
                n.remove();
            }
        });
        return this;
    }
    destroy() {
        this.context.list.forEach((n) => {
            n.removeNodes().remove();
        });
        this.removeNodes();
        this.ogone.component.runtime('destroy');
        this.ogone.component.activated = false;
        this.remove();
    }
    render() {
        const o = this.ogone, oc = o.component;
        if (true) {
            // update Props before replace the element
            oc.updateProps();
            if (this.childNodes.length) {
                this.renderSlots();
            }
            // replace the element
            this.replaceWith(...o.nodes);
            // template/node is already connected
            // ask the component to evaluate the value of the textnodes
            oc.renderTexts(true);
            // trigger the init case of the component
            // we can pass the parameters of the router into the ctx
            oc.startLifecycle(o.params, o.historyState);
        }
        else {
            if (this.childNodes.length) {
                this.renderSlots();
            }
            oc.renderTexts(true);
            this.replaceWith(...o.nodes);
        }
    }
};
customElements.define('data-r35yo-nt', Ogone.classes['data-r35yo-nt'], { extends: 'template' });
          </script>
  </head>
  <body>
      <template is="data-r35yo-nt"></template>
  </body>
</html>
